# 多语言实时翻译系统设计文档

## 概述

本文档描述小傻瓜聊天工具的多语言实时翻译系统架构设计，支持同一对话框内不同语言用户的实时交流，提供三种显示模式满足不同场景需求。

---

## 1. 系统架构设计

### 1.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              客户端层 (Client)                               │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │ 消息输入组件 │  │ 翻译显示组件 │  │ 语言设置面板 │  │ 本地翻译引擎 (WASM)  │ │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  └─────────────────────┘ │
└─────────┼────────────────┼────────────────┼─────────────────────────────────┘
          │                │                │
          ▼                ▼                ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            网关层 (Gateway)                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────────────────┐  │
│  │ WebSocket连接管理 │  │ 消息路由分发    │  │ 用户会话管理                 │  │
│  └─────────────────┘  └─────────────────┘  └─────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                          翻译服务层 (Translation Service)                     │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌────────────────────────────────────────────────────────────────────────┐ │
│  │                        翻译编排器 (Translation Orchestrator)            │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │ │
│  │  │ 语言检测器   │  │ 缓存管理器   │  │ 质量评估器   │  │ 回退处理器   │   │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘   │ │
│  └────────────────────────────────────────────────────────────────────────┘ │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │ Google翻译  │  │ DeepL翻译   │  │ Azure翻译   │  │ 本地模型 (ONNX)      │ │
│  │   适配器    │  │   适配器    │  │   适配器    │  │     适配器          │ │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                            数据层 (Data Layer)                               │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────────────────┐  │
│  │  Redis缓存集群   │  │  PostgreSQL主库 │  │  术语表/词典数据库           │  │
│  │  (翻译缓存)      │  │ (持久化存储)    │  │  (专用查询优化)              │  │
│  └─────────────────┘  └─────────────────┘  └─────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 实时翻译流程

```
┌─────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│ 用户A   │────▶│ 发送消息    │────▶│ 语言检测    │────▶│ 缓存查询    │
│ (中文)  │     │ (中文)      │     │ (zh-CN)     │     │ (Miss)      │
└─────────┘     └─────────────┘     └─────────────┘     └──────┬──────┘
                                                               │
                                                               ▼
┌─────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│ 用户B   │◀────│ 显示翻译    │◀────│ 质量评估    │◀────│ 调用翻译API │
│ (英文)  │     │ (English)   │     │ (Pass)      │     │ (DeepL)     │
└─────────┘     └─────────────┘     └─────────────┘     └─────────────┘
                                                               │
                                                               ▼
                                                        ┌─────────────┐
                                                        │ 写入缓存    │
                                                        │ (TTL: 7天)  │
                                                        └─────────────┘
```

### 1.3 本地+云端混合翻译策略

```typescript
// 混合翻译策略配置
interface HybridTranslationConfig {
  // 本地翻译触发条件
  local: {
    enabled: boolean;
    maxTextLength: number;        // 最大100字符使用本地
    supportedLanguagePairs: string[]; // 支持的语对
    modelPath: string;            // ONNX模型路径
  };
  // 云端翻译触发条件
  cloud: {
    providers: TranslationProvider[];
    fallbackOrder: string[];      // 回退优先级
    timeoutMs: number;            // 超时时间
  };
  // 决策阈值
  thresholds: {
    localConfidence: number;      // 本地置信度阈值 0.85
    cacheHitPriority: boolean;    // 缓存命中优先
  };
}

// 翻译路由决策器
class TranslationRouter {
  async route(text: string, sourceLang: string, targetLang: string): Promise<TranslationStrategy> {
    const cacheKey = this.generateCacheKey(text, sourceLang, targetLang);

    // 1. 优先查询缓存
    const cached = await this.cache.get(cacheKey);
    if (cached) return { type: 'cache', data: cached };

    // 2. 短文本使用本地模型
    if (text.length <= 100 && this.isLocalSupported(sourceLang, targetLang)) {
      return { type: 'local', engine: 'onnx' };
    }

    // 3. 长文本使用云端
    return { type: 'cloud', provider: this.selectProvider(sourceLang, targetLang) };
  }
}
```

### 1.4 消息处理管道

```typescript
// 消息处理管道
class MessageTranslationPipeline {
  private stages: PipelineStage[] = [
    new PreprocessingStage(),      // 文本预处理
    new LanguageDetectionStage(),  // 语言检测
    new TerminologyStage(),        // 术语替换
    new TranslationStage(),        // 核心翻译
    new PostprocessingStage(),     // 后处理
    new QualityCheckStage(),       // 质量检查
    new FormattingStage(),         // 格式渲染
  ];

  async process(message: ChatMessage, userPreference: UserPreference): Promise<TranslatedMessage> {
    let context: PipelineContext = { message, userPreference };

    for (const stage of this.stages) {
      context = await stage.execute(context);
      if (context.shouldHalt) break;
    }

    return this.buildOutput(context);
  }
}

// 各阶段实现
class PreprocessingStage implements PipelineStage {
  async execute(ctx: PipelineContext): Promise<PipelineContext> {
    const { text } = ctx.message;

    // 去除多余空白
    ctx.processedText = text.trim().replace(/\s+/g, ' ');

    // 保护特殊内容（URL、代码块、@提及）
    ctx.protectedSegments = this.extractProtectedSegments(ctx.processedText);
    ctx.processedText = this.replaceWithPlaceholders(ctx.processedText, ctx.protectedSegments);

    return ctx;
  }
}

class TranslationStage implements PipelineStage {
  async execute(ctx: PipelineContext): Promise<PipelineContext> {
    const router = new TranslationRouter();
    const strategy = await router.route(
      ctx.processedText,
      ctx.detectedLanguage,
      ctx.userPreference.targetLanguage
    );

    ctx.translation = await this.executeTranslation(strategy, ctx);
    return ctx;
  }
}
```

---

## 2. 三种显示模式详细设计

### 2.1 模式A：仅显示偏好语言（单语模式）

```typescript
// 单语模式配置
interface MonolingualModeConfig {
  type: 'monolingual';
  displayOptions: {
    showOriginalIndicator: boolean;  // 是否显示原文语言标识
    indicatorPosition: 'inline' | 'tooltip'; // 标识位置
    showTranslationTimestamp: boolean; // 显示翻译时间
  };
}

// React组件实现
const MonolingualMessageBubble: React.FC<MessageProps> = ({ message, userPref }) => {
  const translatedText = useTranslation(message, userPref.targetLanguage);

  return (
    <div className="message-bubble monolingual">
      <div className="message-content">
        {translatedText}
      </div>
      {userPref.showOriginalIndicator && (
        <span className="lang-indicator" title={`原文: ${message.originalLanguage}`}>
          {getLanguageFlag(message.originalLanguage)}
        </span>
      )}
    </div>
  );
};
```

**样式规范：**

```css
/* 单语模式样式 */
.message-bubble.monolingual {
  background: #ffffff;
  border-radius: 12px;
  padding: 12px 16px;
  max-width: 70%;
  position: relative;
}

.message-bubble.monolingual .lang-indicator {
  position: absolute;
  bottom: 4px;
  right: 8px;
  font-size: 12px;
  opacity: 0.6;
  cursor: help;
}
```

### 2.2 模式B：原文+译文双显（双语模式）

```typescript
// 双语模式配置
interface BilingualModeConfig {
  type: 'bilingual';
  layout: 'stacked' | 'side-by-side' | 'toggle';
  originalPosition: 'top' | 'bottom';
  styling: {
    originalSize: 'small' | 'smaller';      // 原文字号
    originalOpacity: number;                 // 原文透明度 0.5-0.7
    originalStyle: 'italic' | 'normal';
    separator: 'line' | 'space' | 'none';
    colorScheme: 'subtle' | 'distinct';
  };
}

// React组件实现
const BilingualMessageBubble: React.FC<MessageProps> = ({ message, userPref }) => {
  const { originalText, translatedText, originalLanguage } = message;
  const config = userPref.displayConfig as BilingualModeConfig;

  return (
    <div className="message-bubble bilingual">
      {config.originalPosition === 'top' ? (
        <>
          <div className="original-text">
            <span className="lang-tag">{originalLanguage}</span>
            {originalText}
          </div>
          <div className="separator" />
          <div className="translated-text">
            {translatedText}
          </div>
        </>
      ) : (
        <>
          <div className="translated-text">
            {translatedText}
          </div>
          <div className="separator" />
          <div className="original-text">
            <span className="lang-tag">{originalLanguage}</span>
            {originalText}
          </div>
        </>
      )}
    </div>
  );
};
```

**样式规范：**

```css
/* 双语模式样式 */
.message-bubble.bilingual {
  background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
  border-radius: 16px;
  padding: 16px;
  max-width: 75%;
  border: 1px solid #e9ecef;
}

.message-bubble.bilingual .original-text {
  font-size: 13px;
  color: #6c757d;
  font-style: italic;
  line-height: 1.5;
  margin-bottom: 8px;
}

.message-bubble.bilingual .original-text .lang-tag {
  display: inline-block;
  background: #e9ecef;
  color: #495057;
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 4px;
  margin-right: 8px;
  font-style: normal;
  font-weight: 500;
}

.message-bubble.bilingual .separator {
  height: 1px;
  background: linear-gradient(90deg, transparent, #dee2e6, transparent);
  margin: 10px 0;
}

.message-bubble.bilingual .translated-text {
  font-size: 15px;
  color: #212529;
  line-height: 1.6;
  font-weight: 400;
}
```

### 2.3 模式C：语言学习模式（学习模式）

```typescript
// 学习模式配置
interface LearningModeConfig {
  type: 'learning';
  annotationLevel: 'word' | 'phrase' | 'sentence';
  displayFeatures: {
    showPronunciation: boolean;      // 显示音标
    showPartOfSpeech: boolean;       // 显示词性
    colorCoding: boolean;            // 词性颜色编码
    difficultyHighlighting: boolean; // 难度高亮
    clickableVocabulary: boolean;    // 可点击查词
  };
  colorScheme: {
    noun: string;        // #4A90D9 - 蓝色
    verb: string;        // #E74C3C - 红色
    adjective: string;   // #27AE60 - 绿色
    adverb: string;      // #F39C12 - 橙色
    other: string;       // #95A5A6 - 灰色
  };
}

// 对齐数据结构
interface AlignedSegment {
  id: string;
  source: {
    text: string;
    tokens: Token[];
    startIndex: number;
    endIndex: number;
  };
  target: {
    text: string;
    tokens: Token[];
    startIndex: number;
    endIndex: number;
  };
  alignment: AlignmentMapping[];
  difficulty: 'beginner' | 'intermediate' | 'advanced';
}

interface Token {
  text: string;
  pos: PartOfSpeech;
  lemma: string;
  pronunciation?: string;
  difficulty: number;
}

// React组件实现
const LearningModeMessageBubble: React.FC<MessageProps> = ({ message, userPref }) => {
  const [selectedWord, setSelectedWord] = useState<Token | null>(null);
  const alignedSegments = useAlignmentAnalysis(message);
  const config = userPref.displayConfig as LearningModeConfig;

  return (
    <div className="message-bubble learning-mode">
      {alignedSegments.map((segment) => (
        <div key={segment.id} className="aligned-segment">
          {/* 原文层 */}
          <div className="source-layer">
            {segment.source.tokens.map((token, idx) => (
              <span
                key={idx}
                className={`token ${token.pos} difficulty-${token.difficulty}`}
                onClick={() => setSelectedWord(token)}
              >
                {token.text}
                {config.displayFeatures.showPronunciation && token.pronunciation && (
                  <span className="pronunciation">/{token.pronunciation}/</span>
                )}
              </span>
            ))}
          </div>

          {/* 对照连接线 */}
          <div className="alignment-lines">
            {segment.alignment.map((mapping, idx) => (
              <AlignmentLine key={idx} mapping={mapping} />
            ))}
          </div>

          {/* 译文层 */}
          <div className="target-layer">
            {segment.target.tokens.map((token, idx) => (
              <span
                key={idx}
                className={`token ${token.pos}`}
                data-mapped-to={getMappedSourceId(segment.alignment, idx)}
              >
                {token.text}
              </span>
            ))}
          </div>
        </div>
      ))}

      {/* 词汇详情弹窗 */}
      {selectedWord && (
        <VocabularyPopup
          token={selectedWord}
          onClose={() => setSelectedWord(null)}
        />
      )}
    </div>
  );
};
```

**样式规范：**

```css
/* 学习模式样式 */
.message-bubble.learning-mode {
  background: #fefefe;
  border-radius: 20px;
  padding: 20px;
  max-width: 85%;
  border: 2px solid #e3f2fd;
}

.aligned-segment {
  margin-bottom: 16px;
  padding: 12px;
  background: #f8f9fa;
  border-radius: 12px;
}

/* 词性颜色编码 */
.token {
  display: inline-block;
  padding: 2px 4px;
  margin: 0 2px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
}

.token:hover {
  transform: scale(1.05);
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.token.noun { background-color: rgba(74, 144, 217, 0.15); color: #2c5aa0; }
.token.verb { background-color: rgba(231, 76, 60, 0.15); color: #c0392b; }
.token.adjective { background-color: rgba(39, 174, 96, 0.15); color: #1e8449; }
.token.adverb { background-color: rgba(243, 156, 18, 0.15); color: #d68910; }
.token.other { background-color: rgba(149, 165, 182, 0.15); color: #5d6d7e; }

/* 难度高亮 */
.token.difficulty-1 { border-bottom: 2px solid #27ae60; }
.token.difficulty-2 { border-bottom: 2px solid #f39c12; }
.token.difficulty-3 { border-bottom: 2px solid #e74c3c; }

/* 音标显示 */
.token .pronunciation {
  display: block;
  font-size: 10px;
  color: #7f8c8d;
  font-style: italic;
  margin-top: 2px;
}

/* 对照连接线 */
.alignment-lines {
  height: 20px;
  position: relative;
  margin: 8px 0;
}

.alignment-line {
  position: absolute;
  height: 2px;
  background: linear-gradient(90deg, #4A90D9, #27AE60);
  opacity: 0.4;
  border-radius: 1px;
}

/* 词汇弹窗 */
.vocabulary-popup {
  position: absolute;
  background: white;
  border-radius: 12px;
  padding: 16px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.15);
  z-index: 100;
  min-width: 250px;
}
```

---

## 3. 语言检测与识别

### 3.1 自动语言检测

```typescript
// 语言检测服务
interface LanguageDetectionResult {
  language: string;           // ISO 639-1 代码
  confidence: number;         // 0-1 置信度
  alternatives: AlternativeLanguage[];
  script: string;             // 文字系统
  isReliable: boolean;        // 是否可靠
}

interface AlternativeLanguage {
  language: string;
  confidence: number;
}

class LanguageDetectionService {
  private detectors: Detector[] = [
    new CLD3Detector(),        // Google CLD3
    new FastTextDetector(),    // Facebook FastText
    new HeuristicDetector(),   // 启发式规则
  ];

  async detect(text: string): Promise<LanguageDetectionResult> {
    // 并行执行多个检测器
    const results = await Promise.all(
      this.detectors.map(d => d.detect(text))
    );

    // 投票融合
    return this.fuseResults(results);
  }

  private fuseResults(results: DetectionResult[]): LanguageDetectionResult {
    // 加权投票算法
    const votes = new Map<string, number>();

    for (const result of results) {
      const weight = this.getDetectorWeight(result.detector);
      votes.set(
        result.language,
        (votes.get(result.language) || 0) + result.confidence * weight
      );
    }

    // 排序取最高
    const sorted = Array.from(votes.entries())
      .sort((a, b) => b[1] - a[1]);

    const topConfidence = sorted[0][1] / results.length;

    return {
      language: sorted[0][0],
      confidence: topConfidence,
      alternatives: sorted.slice(1, 4).map(([lang, conf]) => ({
        language: lang,
        confidence: conf / results.length
      })),
      script: this.detectScript(results[0].text),
      isReliable: topConfidence > 0.8
    };
  }
}

// CLD3检测器实现
class CLD3Detector implements Detector {
  private cld3: any; // CLD3 WASM实例

  async detect(text: string): Promise<DetectionResult> {
    const result = this.cld3.findLanguage(text);
    return {
      detector: 'cld3',
      language: this.normalizeLanguageCode(result.language),
      confidence: result.probability,
      isReliable: result.is_reliable,
      text
    };
  }
}

// 启发式检测器（快速路径）
class HeuristicDetector implements Detector {
  private scriptPatterns: Map<string, RegExp> = new Map([
    ['zh', /[\u4e00-\u9fff]/],
    ['ja', /[\u3040-\u309f\u30a0-\u30ff]/],
    ['ko', /[\uac00-\ud7af]/],
    ['ar', /[\u0600-\u06ff]/],
    ['ru', /[\u0400-\u04ff]/],
  ]);

  async detect(text: string): Promise<DetectionResult> {
    for (const [lang, pattern] of this.scriptPatterns) {
      if (pattern.test(text)) {
        return {
          detector: 'heuristic',
          language: lang,
          confidence: 0.95,
          isReliable: true,
          text
        };
      }
    }

    return {
      detector: 'heuristic',
      language: 'unknown',
      confidence: 0,
      isReliable: false,
      text
    };
  }
}
```

### 3.2 手动语言指定

```typescript
// 手动语言指定
interface ManualLanguageOverride {
  messageId: string;
  specifiedLanguage: string;
  specifiedBy: 'user' | 'admin' | 'auto-correction';
  timestamp: Date;
}

// 用户级语言偏好
interface UserLanguagePreference {
  userId: string;
  primaryLanguage: string;      // 主要语言
  secondaryLanguages: string[]; // 次要语言（可能混用）
  autoDetect: boolean;          // 是否自动检测
  fallbackLanguage: string;     // 检测失败时的默认语言
}

// 对话框级语言设置
interface DialogLanguageSettings {
  dialogId: string;
  participantLanguages: Map<string, string>; // userId -> language
  allowMixedLanguages: boolean;
  defaultTranslationTarget: string;
}
```

### 3.3 置信度评估

```typescript
// 置信度评估器
class ConfidenceEvaluator {
  evaluate(detectionResult: LanguageDetectionResult, context: DetectionContext): ConfidenceAssessment {
    let score = detectionResult.confidence;
    const factors: ConfidenceFactor[] = [];

    // 因素1: 文本长度
    const lengthFactor = this.calculateLengthFactor(context.text.length);
    score *= lengthFactor.weight;
    factors.push(lengthFactor);

    // 因素2: 用户历史语言模式
    const historyFactor = this.calculateHistoryFactor(
      detectionResult.language,
      context.userHistory
    );
    score *= historyFactor.weight;
    factors.push(historyFactor);

    // 因素3: 对话上下文一致性
    const contextFactor = this.calculateContextFactor(
      detectionResult.language,
      context.recentMessages
    );
    score *= contextFactor.weight;
    factors.push(contextFactor);

    // 因素4: 特殊字符/混合文本
    const purityFactor = this.calculatePurityFactor(context.text);
    score *= purityFactor.weight;
    factors.push(purityFactor);

    return {
      finalScore: Math.min(score, 1.0),
      isReliable: score > 0.75,
      factors,
      recommendation: score < 0.5 ? 'prompt_user' : 'auto_translate'
    };
  }

  private calculateLengthFactor(length: number): ConfidenceFactor {
    if (length < 5) return { name: 'length', weight: 0.6, reason: 'text_too_short' };
    if (length < 20) return { name: 'length', weight: 0.85, reason: 'text_short' };
    return { name: 'length', weight: 1.0, reason: 'adequate_length' };
  }
}
```

---

## 4. 翻译引擎集成

### 4.1 支持的服务商

```typescript
// 翻译引擎接口
interface TranslationEngine {
  name: string;
  translate(text: string, options: TranslationOptions): Promise<TranslationResult>;
  batchTranslate(texts: string[], options: TranslationOptions): Promise<TranslationResult[]>;
  detectLanguage(text: string): Promise<LanguageDetectionResult>;
  getSupportedLanguages(): Promise<LanguagePair[]>;
  healthCheck(): Promise<HealthStatus>;
}

// 翻译选项
interface TranslationOptions {
  sourceLanguage: string;
  targetLanguage: string;
  domain?: string;              // 领域：general/medical/legal/technical
  formality?: 'formal' | 'informal';
  glossaryId?: string;          // 术语表ID
  preserveFormatting?: boolean;
}

// Google Translate 适配器
class GoogleTranslateAdapter implements TranslationEngine {
  name = 'google_translate';
  private client: Translate.v2.Translate;

  async translate(text: string, options: TranslationOptions): Promise<TranslationResult> {
    const [translation] = await this.client.translate(text, {
      from: options.sourceLanguage,
      to: options.targetLanguage,
      format: 'text',
    });

    return {
      translatedText: translation,
      sourceLanguage: options.sourceLanguage,
      targetLanguage: options.targetLanguage,
      engine: this.name,
      confidence: 0.9,
      alternatives: [],
    };
  }

  async batchTranslate(texts: string[], options: TranslationOptions): Promise<TranslationResult[]> {
    const [translations] = await this.client.translate(texts, {
      from: options.sourceLanguage,
      to: options.targetLanguage,
    });

    return translations.map((t, i) => ({
      translatedText: t,
      sourceLanguage: options.sourceLanguage,
      targetLanguage: options.targetLanguage,
      engine: this.name,
      confidence: 0.9,
      alternatives: [],
    }));
  }
}

// DeepL 适配器
class DeepLAdapter implements TranslationEngine {
  name = 'deepl';
  private client: DeepL.Translator;

  async translate(text: string, options: TranslationOptions): Promise<TranslationResult> {
    const result = await this.client.translateText(
      text,
      options.sourceLanguage as SourceLanguageCode,
      options.targetLanguage as TargetLanguageCode,
      {
        formality: options.formality === 'formal' ? 'prefer_more' : 'prefer_less',
        preserveFormatting: options.preserveFormatting,
      }
    );

    return {
      translatedText: result.text,
      sourceLanguage: options.sourceLanguage,
      targetLanguage: options.targetLanguage,
      engine: this.name,
      confidence: result.detectedSourceLang ? 0.95 : 0.85,
      detectedSourceLanguage: result.detectedSourceLang?.langCode,
      alternatives: [],
    };
  }
}

// Azure Translator 适配器
class AzureTranslatorAdapter implements TranslationEngine {
  name = 'azure_translator';
  private endpoint: string;
  private key: string;

  async translate(text: string, options: TranslationOptions): Promise<TranslationResult> {
    const response = await fetch(`${this.endpoint}/translate`, {
      method: 'POST',
      headers: {
        'Ocp-Apim-Subscription-Key': this.key,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify([{
        Text: text,
      }]),
    });

    const data = await response.json();
    const translation = data[0].translations[0];

    return {
      translatedText: translation.text,
      sourceLanguage: options.sourceLanguage,
      targetLanguage: options.targetLanguage,
      engine: this.name,
      confidence: 0.88,
      alternatives: [],
    };
  }
}

// 本地ONNX模型适配器
class LocalONNXAdapter implements TranslationEngine {
  name = 'local_onnx';
  private session: ort.InferenceSession;
  private tokenizer: Tokenizer;

  async translate(text: string, options: TranslationOptions): Promise<TranslationResult> {
    // 仅支持短文本和特定语对
    if (text.length > 100) {
      throw new Error('Text too long for local model');
    }

    const tokens = this.tokenizer.encode(text);
    const inputTensor = new ort.Tensor('int64', tokens, [1, tokens.length]);

    const results = await this.session.run({ input: inputTensor });
    const outputTokens = results.output.data as BigInt64Array;
    const translatedText = this.tokenizer.decode(Array.from(outputTokens));

    return {
      translatedText,
      sourceLanguage: options.sourceLanguage,
      targetLanguage: options.targetLanguage,
      engine: this.name,
      confidence: 0.75, // 本地模型置信度较低
      alternatives: [],
      isLocal: true,
    };
  }
}
```

### 4.2 翻译质量评估

```typescript
// 翻译质量评估
interface QualityMetrics {
  bleu?: number;                // BLEU分数
  comet?: number;               // COMET分数
  lengthRatio: number;          // 长度比
  unknownWordRatio: number;     // 未识别词比例
  grammarCheck: GrammarResult;  // 语法检查结果
}

class TranslationQualityEvaluator {
  async evaluate(
    source: string,
    translation: string,
    context: TranslationContext
  ): Promise<QualityAssessment> {
    const metrics: QualityMetrics = {
      lengthRatio: translation.length / source.length,
      unknownWordRatio: await this.calculateUnknownWords(translation),
      grammarCheck: await this.checkGrammar(translation),
    };

    // 启发式质量评分
    let score = 1.0;

    // 长度异常检测
    if (metrics.lengthRatio < 0.3 || metrics.lengthRatio > 3) {
      score -= 0.3;
    }

    // 未识别词检测
    if (metrics.unknownWordRatio > 0.1) {
      score -= 0.2;
    }

    // 语法错误检测
    if (metrics.grammarCheck.errorCount > 0) {
      score -= 0.1 * metrics.grammarCheck.errorCount;
    }

    return {
      score: Math.max(0, score),
      metrics,
      isAcceptable: score > 0.7,
      recommendation: score < 0.5 ? 'retranslate' : 'accept',
    };
  }

  private async calculateUnknownWords(text: string): Promise<number> {
    const words = text.split(/\s+/);
    const dictionary = await this.getDictionary();
    const unknownWords = words.filter(w => !dictionary.has(w.toLowerCase()));
    return unknownWords.length / words.length;
  }
}
```

### 4.3 失败回退机制

```typescript
// 回退策略
interface FallbackStrategy {
  primary: TranslationEngine;
  fallbacks: TranslationEngine[];
  retryPolicy: RetryPolicy;
}

class TranslationOrchestrator {
  private engines: Map<string, TranslationEngine> = new Map();
  private fallbackOrder = ['deepl', 'google_translate', 'azure_translator', 'local_onnx'];

  async translateWithFallback(
    text: string,
    options: TranslationOptions
  ): Promise<TranslationResult> {
    const errors: Error[] = [];

    for (const engineName of this.fallbackOrder) {
      const engine = this.engines.get(engineName);
      if (!engine) continue;

      try {
        // 健康检查
        const health = await engine.healthCheck();
        if (!health.healthy) {
          errors.push(new Error(`${engineName} is unhealthy`));
          continue;
        }

        // 执行翻译
        const result = await this.executeWithTimeout(
          () => engine.translate(text, options),
          5000 // 5秒超时
        );

        // 质量评估
        const quality = await this.qualityEvaluator.evaluate(
          text,
          result.translatedText,
          { sourceLang: options.sourceLanguage, targetLang: options.targetLanguage }
        );

        if (quality.isAcceptable) {
          return { ...result, quality };
        }

        // 质量不合格，记录并尝试下一个
        errors.push(new Error(`${engineName} quality too low: ${quality.score}`));

      } catch (error) {
        errors.push(error as Error);
      }
    }

    // 所有引擎失败
    throw new TranslationError('All translation engines failed', errors);
  }

  // 降级策略：返回原文
  async translateWithGracefulDegradation(
    text: string,
    options: TranslationOptions
  ): Promise<TranslationResult> {
    try {
      return await this.translateWithFallback(text, options);
    } catch (error) {
      // 降级：返回原文，标记为未翻译
      return {
        translatedText: text,
        sourceLanguage: options.sourceLanguage,
        targetLanguage: options.targetLanguage,
        engine: 'fallback_original',
        confidence: 0,
        isFallback: true,
        error: (error as Error).message,
      };
    }
  }
}
```

---

## 5. 性能优化

### 5.1 翻译缓存策略

```typescript
// 缓存键生成
function generateCacheKey(text: string, sourceLang: string, targetLang: string): string {
  const normalizedText = text.trim().toLowerCase().replace(/\s+/g, ' ');
  const hash = crypto.createHash('sha256').update(normalizedText).digest('hex');
  return `trans:${sourceLang}:${targetLang}:${hash}`;
}

// 多级缓存实现
class TranslationCache {
  private l1Cache: Map<string, CacheEntry>;        // 内存缓存
  private l2Cache: Redis;                           // Redis缓存
  private l3Cache: PostgreSQL;                      // 数据库缓存

  async get(key: string): Promise<TranslationResult | null> {
    // L1: 内存缓存
    const l1Entry = this.l1Cache.get(key);
    if (l1Entry && !this.isExpired(l1Entry)) {
      return l1Entry.data;
    }

    // L2: Redis缓存
    const l2Entry = await this.l2Cache.get(key);
    if (l2Entry) {
      const parsed = JSON.parse(l2Entry);
      this.l1Cache.set(key, { data: parsed, timestamp: Date.now() });
      return parsed;
    }

    // L3: 数据库缓存
    const l3Entry = await this.l3Cache.query(
      'SELECT * FROM translation_cache WHERE cache_key = $1 AND expires_at > NOW()',
      [key]
    );
    if (l3Entry.rows.length > 0) {
      const data = l3Entry.rows[0].translation_data;
      await this.l2Cache.setex(key, 3600, JSON.stringify(data)); // 回填Redis
      return data;
    }

    return null;
  }

  async set(key: string, result: TranslationResult, ttl: number = 604800): Promise<void> {
    const entry = { data: result, timestamp: Date.now() };

    // L1: 内存缓存（5分钟）
    this.l1Cache.set(key, entry);

    // L2: Redis缓存（7天）
    await this.l2Cache.setex(key, ttl, JSON.stringify(result));

    // L3: 数据库缓存（30天）
    await this.l3Cache.query(
      `INSERT INTO translation_cache (cache_key, source_text, translation_data, expires_at)
       VALUES ($1, $2, $3, NOW() + INTERVAL '30 days')
       ON CONFLICT (cache_key) DO UPDATE SET
         translation_data = EXCLUDED.translation_data,
         expires_at = EXCLUDED.expires_at,
         hit_count = translation_cache.hit_count + 1`,
      [key, result.sourceText, JSON.stringify(result)]
    );
  }
}
```

### 5.2 流式翻译实现

```typescript
// 流式翻译服务
class StreamingTranslationService {
  private buffer: string = '';
  private sentenceBuffer: string[] = [];
  private readonly SENTENCE_DELIMITERS = /[.!?。！？\n]+/;

  async *translateStream(
    textStream: AsyncIterable<string>,
    options: TranslationOptions
  ): AsyncIterable<TranslationChunk> {
    for await (const chunk of textStream) {
      this.buffer += chunk;

      // 检测完整句子
      const sentences = this.extractCompleteSentences(this.buffer);

      for (const sentence of sentences) {
        // 检查缓存
        const cacheKey = generateCacheKey(sentence, options.sourceLanguage, options.targetLanguage);
        const cached = await this.cache.get(cacheKey);

        if (cached) {
          yield { type: 'translation', text: cached.translatedText, isCached: true };
        } else {
          // 实时翻译
          const result = await this.translateSentence(sentence, options);
          await this.cache.set(cacheKey, result);
          yield { type: 'translation', text: result.translatedText, isCached: false };
        }
      }
    }

    // 处理剩余缓冲区
    if (this.buffer.trim()) {
      const result = await this.translateSentence(this.buffer.trim(), options);
      yield { type: 'translation', text: result.translatedText, isCached: false };
    }
  }

  private extractCompleteSentences(text: string): string[] {
    const parts = text.split(this.SENTENCE_DELIMITERS);
    const complete = parts.slice(0, -1);
    this.buffer = parts[parts.length - 1];
    return complete.filter(s => s.trim());
  }
}

// WebSocket流式传输
class WebSocketTranslationHandler {
  async handleStream(ws: WebSocket, options: TranslationOptions) {
    const streamService = new StreamingTranslationService();

    ws.on('message', async (data: string) => {
      const message = JSON.parse(data);

      if (message.type === 'text_chunk') {
        const stream = this.createTextStream(message.chunks);

        for await (const translation of streamService.translateStream(stream, options)) {
          ws.send(JSON.stringify({
            type: 'translation_chunk',
            text: translation.text,
            isCached: translation.isCached,
            timestamp: Date.now(),
          }));
        }
      }
    });
  }
}
```

### 5.3 预加载机制

```typescript
// 预加载服务
class PreloadService {
  private priorityQueue: PriorityQueue<PreloadTask>;
  private userContextCache: Map<string, UserContext>;

  // 基于上下文的预加载
  async preloadBasedOnContext(dialogId: string, userId: string): Promise<void> {
    const context = await this.getUserContext(dialogId, userId);

    // 1. 预加载常见短语
    await this.preloadCommonPhrases(context);

    // 2. 预加载对话历史中的高频词汇
    await this.preloadFrequentTerms(context);

    // 3. 预加载用户术语表
    await this.preloadUserGlossary(userId);
  }

  // 智能预加载（基于输入预测）
  async predictivePreload(partialInput: string, userPref: UserPreference): Promise<void> {
    // 获取输入建议
    const suggestions = await this.getInputSuggestions(partialInput);

    for (const suggestion of suggestions.slice(0, 3)) {
      const cacheKey = generateCacheKey(
        suggestion,
        userPref.primaryLanguage,
        userPref.targetLanguage
      );

      // 后台预翻译
      this.backgroundTranslate(suggestion, userPref).then(result => {
        this.cache.set(cacheKey, result, 3600); // 1小时TTL
      });
    }
  }

  // 批量预加载
  async batchPreload(texts: string[], options: TranslationOptions): Promise<void> {
    // 去重
    const uniqueTexts = [...new Set(texts)];

    // 分批处理（每批10条）
    const batches = this.chunkArray(uniqueTexts, 10);

    for (const batch of batches) {
      // 检查缓存缺失
      const missingTexts: string[] = [];
      for (const text of batch) {
        const cacheKey = generateCacheKey(text, options.sourceLanguage, options.targetLanguage);
        const cached = await this.cache.get(cacheKey);
        if (!cached) missingTexts.push(text);
      }

      if (missingTexts.length > 0) {
        // 批量翻译
        const results = await this.translationEngine.batchTranslate(missingTexts, options);

        // 写入缓存
        for (let i = 0; i < missingTexts.length; i++) {
          const cacheKey = generateCacheKey(
            missingTexts[i],
            options.sourceLanguage,
            options.targetLanguage
          );
          await this.cache.set(cacheKey, results[i]);
        }
      }
    }
  }
}
```

---

## 6. 术语表与个人词典

### 6.1 用户自定义词汇

```typescript
// 用户自定义词汇
interface UserVocabulary {
  id: string;
  userId: string;
  term: string;                 // 原文词汇
  translation: string;          // 译文
  context?: string;             // 使用语境
  partOfSpeech?: string;        // 词性
  notes?: string;               // 备注
  priority: number;             // 优先级 1-10
  createdAt: Date;
  updatedAt: Date;
  usageCount: number;           // 使用次数
}

// 词汇管理服务
class UserVocabularyService {
  // 添加自定义词汇
  async addVocabulary(userId: string, vocab: Omit<UserVocabulary, 'id' | 'userId'>): Promise<UserVocabulary> {
    const existing = await this.db.query(
      'SELECT * FROM user_vocabulary WHERE user_id = $1 AND term = $2',
      [userId, vocab.term]
    );

    if (existing.rows.length > 0) {
      // 更新现有词汇
      const updated = await this.db.query(
        `UPDATE user_vocabulary
         SET translation = $1, context = $2, notes = $3, priority = $4, updated_at = NOW()
         WHERE id = $5 RETURNING *`,
        [vocab.translation, vocab.context, vocab.notes, vocab.priority, existing.rows[0].id]
      );
      return updated.rows[0];
    }

    // 创建新词汇
    const result = await this.db.query(
      `INSERT INTO user_vocabulary
       (user_id, term, translation, context, part_of_speech, notes, priority)
       VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING *`,
      [userId, vocab.term, vocab.translation, vocab.context, vocab.partOfSpeech, vocab.notes, vocab.priority]
    );

    // 清除相关缓存
    await this.invalidateVocabularyCache(userId);

    return result.rows[0];
  }

  // 应用用户词汇到翻译
  async applyUserVocabulary(text: string, userId: string): Promise<ProcessedText> {
    const vocabularies = await this.getUserVocabularies(userId);
    let processedText = text;
    const appliedTerms: AppliedTerm[] = [];

    // 按优先级排序
    const sortedVocab = vocabularies.sort((a, b) => b.priority - a.priority);

    for (const vocab of sortedVocab) {
      const regex = new RegExp(`\\b${this.escapeRegex(vocab.term)}\\b`, 'gi');
      if (regex.test(processedText)) {
        processedText = processedText.replace(regex, `{{${vocab.id}}}`);
        appliedTerms.push({
          id: vocab.id,
          original: vocab.term,
          replacement: vocab.translation,
          position: this.findPosition(processedText, vocab.id),
        });
      }
    }

    return { text: processedText, appliedTerms, placeholders: appliedTerms.map(t => t.id) };
  }

  // 恢复占位符
  restorePlaceholders(translatedText: string, appliedTerms: AppliedTerm[]): string {
    let result = translatedText;
    for (const term of appliedTerms) {
      result = result.replace(new RegExp(`{{${term.id}}}`, 'g'), term.replacement);
    }
    return result;
  }
}
```

### 6.2 专业术语管理

```typescript
// 专业术语表
interface Glossary {
  id: string;
  name: string;
  description?: string;
  domain: string;               // 领域：medical/legal/technical/business
  sourceLanguage: string;
  targetLanguage: string;
  entries: GlossaryEntry[];
  isPublic: boolean;
  createdBy: string;
  createdAt: Date;
}

interface GlossaryEntry {
  id: string;
  glossaryId: string;
  term: string;
  translation: string;
  alternatives?: string[];      // 替代译法
  definition?: string;          // 定义
  usageExample?: string;        // 使用示例
  partOfSpeech?: string;
  approved: boolean;            // 是否已审核
}

// 术语表服务
class GlossaryService {
  // 创建术语表
  async createGlossary(glossary: Omit<Glossary, 'id'>): Promise<Glossary> {
    const result = await this.db.query(
      `INSERT INTO glossaries (name, description, domain, source_language, target_language, is_public, created_by)
       VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING *`,
      [glossary.name, glossary.description, glossary.domain, glossary.sourceLanguage,
       glossary.targetLanguage, glossary.isPublic, glossary.createdBy]
    );
    return result.rows[0];
  }

  // 导入术语（支持CSV/XLSX）
  async importGlossary(glossaryId: string, file: Buffer, format: 'csv' | 'xlsx'): Promise<ImportResult> {
    const entries = format === 'csv'
      ? await this.parseCSV(file)
      : await this.parseXLSX(file);

    const imported: GlossaryEntry[] = [];
    const errors: ImportError[] = [];

    for (const entry of entries) {
      try {
        const result = await this.db.query(
          `INSERT INTO glossary_entries
           (glossary_id, term, translation, alternatives, definition, usage_example, part_of_speech)
           VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING *`,
          [glossaryId, entry.term, entry.translation, entry.alternatives,
           entry.definition, entry.usageExample, entry.partOfSpeech]
        );
        imported.push(result.rows[0]);
      } catch (error) {
        errors.push({ row: entry.rowNumber, error: (error as Error).message });
      }
    }

    return { imported: imported.length, errors };
  }

  // 术语匹配与替换
  async applyGlossary(text: string, glossaryIds: string[]): Promise<ProcessedText> {
    const allEntries = await this.getGlossaryEntries(glossaryIds);

    // 构建Trie树进行高效匹配
    const trie = this.buildTrie(allEntries);
    const matches = this.findMatches(text, trie);

    // 应用替换（最长匹配优先）
    let processedText = text;
    const appliedTerms: AppliedTerm[] = [];

    for (const match of matches.sort((a, b) => b.length - a.length)) {
      const entry = allEntries.find(e => e.term === match.term);
      if (entry && !this.isOverlapping(appliedTerms, match)) {
        processedText = this.replaceAt(
          processedText,
          match.start,
          match.length,
          `[[${entry.id}]]`
        );
        appliedTerms.push({
          id: entry.id,
          original: entry.term,
          replacement: entry.translation,
          position: match.start,
        });
      }
    }

    return { text: processedText, appliedTerms };
  }
}
```

### 6.3 翻译记忆

```typescript
// 翻译记忆单元
interface TranslationMemoryUnit {
  id: string;
  sourceSegment: string;        // 源语段
  targetSegment: string;        // 目标语段
  sourceLanguage: string;
  targetLanguage: string;
  domain?: string;
  context?: string;             // 上下文信息
  createdBy?: string;           // 创建者
  usageCount: number;           // 使用次数
  lastUsedAt?: Date;
  createdAt: Date;
  matchQuality: number;         // 匹配质量评分
}

// 翻译记忆服务
class TranslationMemoryService {
  // 模糊匹配搜索
  async findMatches(
    sourceText: string,
    sourceLang: string,
    targetLang: string,
    threshold: number = 0.7
  ): Promise<TMMatch[]> {
    // 使用pg_trgm进行相似度搜索
    const result = await this.db.query(
      `SELECT *, similarity(source_segment, $1) as sim
       FROM translation_memory
       WHERE source_language = $2 AND target_language = $3
         AND source_segment % $1
       ORDER BY similarity(source_segment, $1) DESC
       LIMIT 5`,
      [sourceText, sourceLang, targetLang]
    );

    return result.rows
      .filter(row => row.sim >= threshold)
      .map(row => ({
        tmUnit: row,
        matchScore: this.calculateMatchScore(sourceText, row.source_segment, row.sim),
        differences: this.calculateDifferences(sourceText, row.source_segment),
      }));
  }

  // 计算匹配分数（结合多种算法）
  private calculateMatchScore(input: string, candidate: string, trigramSim: number): number {
    const levenshteinSim = 1 - (this.levenshteinDistance(input, candidate) / Math.max(input.length, candidate.length));
    const jaroWinklerSim = this.jaroWinklerDistance(input, candidate);

    // 加权平均
    return (trigramSim * 0.3 + levenshteinSim * 0.3 + jaroWinklerSim * 0.4);
  }

  // 添加翻译记忆
  async addTMUnit(unit: Omit<TranslationMemoryUnit, 'id'>): Promise<TranslationMemoryUnit> {
    // 检查重复
    const existing = await this.db.query(
      'SELECT id FROM translation_memory WHERE source_segment = $1 AND target_segment = $2',
      [unit.sourceSegment, unit.targetSegment]
    );

    if (existing.rows.length > 0) {
      // 更新使用次数
      await this.db.query(
        `UPDATE translation_memory
         SET usage_count = usage_count + 1, last_used_at = NOW()
         WHERE id = $1`,
        [existing.rows[0].id]
      );
      return existing.rows[0];
    }

    const result = await this.db.query(
      `INSERT INTO translation_memory
       (source_segment, target_segment, source_language, target_language, domain, context, created_by)
       VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING *`,
      [unit.sourceSegment, unit.targetSegment, unit.sourceLanguage,
       unit.targetLanguage, unit.domain, unit.context, unit.createdBy]
    );

    return result.rows[0];
  }

  // 利用翻译记忆进行预翻译
  async pretranslateWithTM(
    segments: string[],
    sourceLang: string,
    targetLang: string,
    threshold: number = 0.95
  ): Promise<PretranslationResult> {
    const results: (string | null)[] = [];
    const tmMatches: TMMatch[] = [];

    for (const segment of segments) {
      const matches = await this.findMatches(segment, sourceLang, targetLang, threshold);

      if (matches.length > 0 && matches[0].matchScore >= threshold) {
        results.push(matches[0].tmUnit.targetSegment);
        tmMatches.push(matches[0]);
      } else {
        results.push(null);
      }
    }

    return {
      pretranslated: results,
      tmMatches,
      coverage: results.filter(r => r !== null).length / results.length,
    };
  }
}
```

---

## 7. 数据库设计

### 7.1 翻译缓存表

```sql
-- 翻译缓存表
CREATE TABLE translation_cache (
    id BIGSERIAL PRIMARY KEY,
    cache_key VARCHAR(64) NOT NULL UNIQUE,  -- SHA256哈希
    source_text TEXT NOT NULL,
    source_language VARCHAR(10) NOT NULL,
    target_language VARCHAR(10) NOT NULL,
    translated_text TEXT NOT NULL,
    translation_engine VARCHAR(50) NOT NULL,
    confidence DECIMAL(3,2) DEFAULT 0.9,
    quality_score DECIMAL(3,2),
    hit_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,

    CONSTRAINT valid_confidence CHECK (confidence >= 0 AND confidence <= 1)
);

-- 索引
CREATE INDEX idx_translation_cache_lookup
    ON translation_cache(cache_key, expires_at);
CREATE INDEX idx_translation_cache_languages
    ON translation_cache(source_language, target_language);
CREATE INDEX idx_translation_cache_expires
    ON translation_cache(expires_at)
    WHERE expires_at < NOW() + INTERVAL '1 day';

-- 分区（按创建时间，每月分区）
CREATE TABLE translation_cache_y2024m01 PARTITION OF translation_cache
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
```

### 7.2 用户语言偏好表

```sql
-- 用户语言偏好表
CREATE TABLE user_language_preferences (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    -- 主要设置
    primary_language VARCHAR(10) NOT NULL DEFAULT 'zh-CN',
    target_language VARCHAR(10) NOT NULL DEFAULT 'en',

    -- 次要语言（JSON数组）
    secondary_languages JSONB DEFAULT '[]',

    -- 显示模式: monolingual/bilingual/learning
    display_mode VARCHAR(20) NOT NULL DEFAULT 'monolingual',
    display_config JSONB DEFAULT '{}',

    -- 自动检测设置
    auto_detect_language BOOLEAN DEFAULT TRUE,
    fallback_language VARCHAR(10) DEFAULT 'en',

    -- 翻译引擎偏好
    preferred_engine VARCHAR(50) DEFAULT 'deepl',
    engine_fallback_order JSONB DEFAULT '["deepl", "google", "azure"]',

    -- 学习模式设置
    learning_mode_config JSONB DEFAULT '{
        "annotationLevel": "word",
        "showPronunciation": true,
        "showPartOfSpeech": true,
        "colorCoding": true
    }',

    -- 启用的术语表
    enabled_glossaries JSONB DEFAULT '[]',

    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    UNIQUE(user_id)
);

-- 索引
CREATE INDEX idx_user_lang_pref_user ON user_language_preferences(user_id);
CREATE INDEX idx_user_lang_pref_primary ON user_language_preferences(primary_language);

-- 更新触发器
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_user_lang_pref_updated_at
    BEFORE UPDATE ON user_language_preferences
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### 7.3 术语表结构

```sql
-- 术语表
CREATE TABLE glossaries (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    domain VARCHAR(50) NOT NULL,  -- medical/legal/technical/business/general
    source_language VARCHAR(10) NOT NULL,
    target_language VARCHAR(10) NOT NULL,
    is_public BOOLEAN DEFAULT FALSE,
    is_system BOOLEAN DEFAULT FALSE,  -- 系统内置术语表
    created_by BIGINT REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 术语表条目
CREATE TABLE glossary_entries (
    id BIGSERIAL PRIMARY KEY,
    glossary_id BIGINT NOT NULL REFERENCES glossaries(id) ON DELETE CASCADE,
    term VARCHAR(500) NOT NULL,
    translation VARCHAR(500) NOT NULL,
    alternatives TEXT[],  -- 替代译法
    definition TEXT,
    usage_example TEXT,
    part_of_speech VARCHAR(20),
    approved BOOLEAN DEFAULT FALSE,
    priority INTEGER DEFAULT 5,  -- 1-10
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    UNIQUE(glossary_id, term)
);

-- 用户词汇表
CREATE TABLE user_vocabulary (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    term VARCHAR(500) NOT NULL,
    translation VARCHAR(500) NOT NULL,
    context TEXT,
    part_of_speech VARCHAR(20),
    notes TEXT,
    priority INTEGER DEFAULT 5,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    UNIQUE(user_id, term)
);

-- 翻译记忆库
CREATE TABLE translation_memory (
    id BIGSERIAL PRIMARY KEY,
    source_segment TEXT NOT NULL,
    target_segment TEXT NOT NULL,
    source_language VARCHAR(10) NOT NULL,
    target_language VARCHAR(10) NOT NULL,
    domain VARCHAR(50),
    context TEXT,
    created_by BIGINT REFERENCES users(id),
    usage_count INTEGER DEFAULT 0,
    last_used_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    -- 用于模糊搜索的trgm索引
    CONSTRAINT unique_segment_pair UNIQUE(source_segment, target_segment, source_language, target_language)
);

-- GIN索引用于模糊搜索
CREATE INDEX idx_tm_source_trgm ON translation_memory
    USING gin(source_segment gin_trgm_ops);

-- 复合索引
CREATE INDEX idx_tm_languages ON translation_memory(source_language, target_language);
CREATE INDEX idx_tm_domain ON translation_memory(domain) WHERE domain IS NOT NULL;

-- 用户术语表关联
CREATE TABLE user_glossary_subscriptions (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    glossary_id BIGINT NOT NULL REFERENCES glossaries(id) ON DELETE CASCADE,
    is_active BOOLEAN DEFAULT TRUE,
    custom_priority INTEGER,  -- 用户自定义优先级
    subscribed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

    UNIQUE(user_id, glossary_id)
);
```

---

## 8. API接口设计

### 8.1 翻译请求API

```typescript
// POST /api/v1/translate
// 请求体
interface TranslateRequest {
  text: string;                           // 待翻译文本
  sourceLanguage?: string;                // 源语言（可选，自动检测）
  targetLanguage: string;                 // 目标语言
  dialogId?: string;                      // 对话框ID（用于上下文）
  messageId?: string;                     // 消息ID（用于缓存关联）
  options?: {
    domain?: string;                      // 专业领域
    formality?: 'formal' | 'informal';    // 正式程度
    useCache?: boolean;                   // 是否使用缓存（默认true）
    timeout?: number;                     // 超时时间（毫秒）
  };
}

// 响应体
interface TranslateResponse {
  success: boolean;
  data?: {
    translatedText: string;
    sourceLanguage: string;
    targetLanguage: string;
    detectedLanguage?: string;            // 如果源语言未指定
    engine: string;                       // 使用的翻译引擎
    confidence: number;
    isCached: boolean;
    alternatives?: string[];              // 替代译法
    processingTime: number;               // 处理时间（毫秒）
  };
  error?: {
    code: string;
    message: string;
    details?: any;
  };
}

// 批量翻译接口
// POST /api/v1/translate/batch
interface BatchTranslateRequest {
  items: {
    id: string;                           // 客户端标识
    text: string;
    sourceLanguage?: string;
    targetLanguage: string;
  }[];
  options?: TranslateRequest['options'];
}

interface BatchTranslateResponse {
  success: boolean;
  data?: {
    results: {
      id: string;
      translatedText: string;
      sourceLanguage: string;
      confidence: number;
    }[];
    failed: {
      id: string;
      error: string;
    }[];
  };
}

// 流式翻译接口（WebSocket）
// WS /ws/translate
interface StreamTranslateMessage {
  type: 'translate_stream';
  payload: {
    streamId: string;
    chunks: string[];                     // 文本块数组
    targetLanguage: string;
    sourceLanguage?: string;
  };
}

interface StreamTranslateResponse {
  type: 'translation_chunk' | 'translation_complete' | 'error';
  streamId: string;
  payload: {
    chunkIndex?: number;
    translatedText?: string;
    isCached?: boolean;
    error?: string;
  };
}
```

### 8.2 语言检测API

```typescript
// POST /api/v1/detect-language
// 请求体
interface DetectLanguageRequest {
  text: string;
  hintLanguages?: string[];               // 提示语言（提高准确性）
  returnAlternatives?: boolean;           // 返回备选语言
}

// 响应体
interface DetectLanguageResponse {
  success: boolean;
  data?: {
    language: string;                     // ISO 639-1 代码
    confidence: number;                   // 0-1
    script: string;                       // 文字系统
    isReliable: boolean;
    alternatives?: {
      language: string;
      confidence: number;
    }[];
    processingTime: number;
  };
  error?: {
    code: string;
    message: string;
  };
}

// 批量检测接口
// POST /api/v1/detect-language/batch
interface BatchDetectRequest {
  texts: string[];
  hintLanguages?: string[];
}

interface BatchDetectResponse {
  success: boolean;
  data?: {
    results: {
      language: string;
      confidence: number;
      isReliable: boolean;
    }[];
  };
}
```

### 8.3 偏好设置API

```typescript
// 获取用户语言偏好
// GET /api/v1/users/{userId}/language-preferences
interface GetPreferencesResponse {
  success: boolean;
  data?: {
    userId: string;
    primaryLanguage: string;
    targetLanguage: string;
    secondaryLanguages: string[];
    displayMode: 'monolingual' | 'bilingual' | 'learning';
    displayConfig: DisplayConfig;
    autoDetectLanguage: boolean;
    fallbackLanguage: string;
    preferredEngine: string;
    enabledGlossaries: string[];
    learningModeConfig: LearningModeConfig;
  };
}

// 更新用户语言偏好
// PUT /api/v1/users/{userId}/language-preferences
interface UpdatePreferencesRequest {
  primaryLanguage?: string;
  targetLanguage?: string;
  secondaryLanguages?: string[];
  displayMode?: 'monolingual' | 'bilingual' | 'learning';
  displayConfig?: Partial<DisplayConfig>;
  autoDetectLanguage?: boolean;
  fallbackLanguage?: string;
  preferredEngine?: string;
  enabledGlossaries?: string[];
  learningModeConfig?: Partial<LearningModeConfig>;
}

// 对话框语言设置
// GET /api/v1/dialogs/{dialogId}/language-settings
interface GetDialogLanguageSettingsResponse {
  success: boolean;
  data?: {
    dialogId: string;
    allowMixedLanguages: boolean;
    defaultTranslationTarget: string;
    participantLanguages: {
      userId: string;
      language: string;
      autoDetected: boolean;
    }[];
  };
}

// 更新对话框语言设置
// PUT /api/v1/dialogs/{dialogId}/language-settings
interface UpdateDialogLanguageSettingsRequest {
  allowMixedLanguages?: boolean;
  defaultTranslationTarget?: string;
  participantLanguages?: {
    userId: string;
    language: string;
  }[];
}

// 术语表管理API
// GET /api/v1/glossaries
interface ListGlossariesResponse {
  success: boolean;
  data?: {
    glossaries: {
      id: string;
      name: string;
      domain: string;
      sourceLanguage: string;
      targetLanguage: string;
      entryCount: number;
      isPublic: boolean;
      isSubscribed: boolean;
    }[];
  };
}

// 用户词汇管理API
// GET /api/v1/users/{userId}/vocabulary
// POST /api/v1/users/{userId}/vocabulary
// PUT /api/v1/users/{userId}/vocabulary/{vocabId}
// DELETE /api/v1/users/{userId}/vocabulary/{vocabId}
```

---

## 9. UI/UX设计规范

### 9.1 消息气泡样式

```typescript
// 消息气泡组件
interface MessageBubbleProps {
  message: TranslatedMessage;
  displayMode: DisplayMode;
  isOwnMessage: boolean;
  showTimestamp: boolean;
  onLanguageIndicatorClick?: () => void;
}

// 基础样式变量
const messageStyles = {
  // 尺寸
  bubble: {
    maxWidth: '75%',
    minWidth: '120px',
    padding: '12px 16px',
    borderRadius: '16px',
  },

  // 颜色方案
  colors: {
    own: {
      background: '#007AFF',
      text: '#FFFFFF',
      secondaryText: 'rgba(255,255,255,0.8)',
    },
    other: {
      background: '#F2F2F7',
      text: '#000000',
      secondaryText: 'rgba(0,0,0,0.6)',
    },
    learning: {
      background: '#FFFFFF',
      border: '#E3F2FD',
      highlight: '#FFF3E0',
    },
  },

  // 字体
  typography: {
    primary: {
      fontSize: '15px',
      lineHeight: '1.5',
      fontWeight: 400,
    },
    secondary: {
      fontSize: '13px',
      lineHeight: '1.4',
      fontWeight: 400,
    },
    meta: {
      fontSize: '11px',
      lineHeight: '1.3',
      fontWeight: 400,
    },
  },
};
```

```css
/* 消息气泡基础样式 */
.message-bubble {
  position: relative;
  max-width: 75%;
  padding: 12px 16px;
  border-radius: 16px;
  word-wrap: break-word;
  animation: messageAppear 0.2s ease-out;
}

@keyframes messageAppear {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* 自己的消息 */
.message-bubble.own {
  background: linear-gradient(135deg, #007AFF 0%, #0056CC 100%);
  color: white;
  align-self: flex-end;
  border-bottom-right-radius: 4px;
}

/* 他人的消息 */
.message-bubble.other {
  background: #F2F2F7;
  color: #000000;
  align-self: flex-start;
  border-bottom-left-radius: 4px;
}

/* 翻译状态指示器 */
.translation-indicator {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  font-size: 11px;
  opacity: 0.7;
  margin-top: 6px;
  cursor: pointer;
  transition: opacity 0.2s;
}

.translation-indicator:hover {
  opacity: 1;
}

.translation-indicator .icon {
  width: 12px;
  height: 12px;
}
```

### 9.2 语言标识显示

```typescript
// 语言标识组件
interface LanguageIndicatorProps {
  language: string;
  showFlag?: boolean;
  showCode?: boolean;
  showName?: boolean;
  size?: 'small' | 'medium' | 'large';
  variant?: 'badge' | 'text' | 'chip';
}

// 语言代码到国旗emoji映射
const languageFlags: Record<string, string> = {
  'zh': '🇨🇳',
  'zh-CN': '🇨🇳',
  'zh-TW': '🇹🇼',
  'en': '🇬🇧',
  'en-US': '🇺🇸',
  'en-GB': '🇬🇧',
  'ja': '🇯🇵',
  'ko': '🇰🇷',
  'fr': '🇫🇷',
  'de': '🇩🇪',
  'es': '🇪🇸',
  'ru': '🇷🇺',
  'ar': '🇸🇦',
  'pt': '🇵🇹',
  'it': '🇮🇹',
  'nl': '🇳🇱',
  'pl': '🇵🇱',
  'tr': '🇹🇷',
  'vi': '🇻🇳',
  'th': '🇹🇭',
  'id': '🇮🇩',
  'ms': '🇲🇾',
  // ... 更多语言
};

// 语言名称映射
const languageNames: Record<string, string> = {
  'zh': '中文',
  'zh-CN': '简体中文',
  'zh-TW': '繁體中文',
  'en': 'English',
  'en-US': 'English (US)',
  'ja': '日本語',
  'ko': '한국어',
  'fr': 'Français',
  'de': 'Deutsch',
  'es': 'Español',
  // ...
};
```

```css
/* 语言标识样式 */
.language-indicator {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

.language-indicator.badge {
  background: rgba(0, 0, 0, 0.1);
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 500;
}

.language-indicator.chip {
  background: #E3F2FD;
  color: #1976D2;
  padding: 4px 10px;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 500;
}

.language-indicator .flag {
  font-size: 14px;
  line-height: 1;
}

.language-indicator.small .flag {
  font-size: 12px;
}

.language-indicator.large .flag {
  font-size: 18px;
}
```

### 9.3 切换交互设计

```typescript
// 显示模式切换器
interface DisplayModeSwitcherProps {
  currentMode: DisplayMode;
  onModeChange: (mode: DisplayMode) => void;
  supportedModes: DisplayMode[];
}

const DisplayModeSwitcher: React.FC<DisplayModeSwitcherProps> = ({
  currentMode,
  onModeChange,
  supportedModes,
}) => {
  const modes: { id: DisplayMode; label: string; icon: string; description: string }[] = [
    {
      id: 'monolingual',
      label: '单语模式',
      icon: 'Translate',
      description: '仅显示翻译后的文本',
    },
    {
      id: 'bilingual',
      label: '双语模式',
      icon: 'Compare',
      description: '同时显示原文和译文',
    },
    {
      id: 'learning',
      label: '学习模式',
      icon: 'School',
      description: '标注词性和对照关系',
    },
  ];

  return (
    <div className="display-mode-switcher">
      {modes.map((mode) => (
        <button
          key={mode.id}
          className={`mode-button ${currentMode === mode.id ? 'active' : ''}`}
          onClick={() => onModeChange(mode.id)}
          disabled={!supportedModes.includes(mode.id)}
          title={mode.description}
        >
          <Icon name={mode.icon} />
          <span>{mode.label}</span>
        </button>
      ))}
    </div>
  );
};
```

```css
/* 模式切换器样式 */
.display-mode-switcher {
  display: flex;
  gap: 8px;
  padding: 4px;
  background: #F2F2F7;
  border-radius: 12px;
}

.mode-button {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 14px;
  border: none;
  background: transparent;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 500;
  color: #666;
  cursor: pointer;
  transition: all 0.2s;
}

.mode-button:hover:not(:disabled) {
  background: rgba(0, 0, 0, 0.05);
}

.mode-button.active {
  background: white;
  color: #007AFF;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.mode-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

/* 快速设置面板 */
.quick-settings-panel {
  position: absolute;
  top: 100%;
  right: 0;
  margin-top: 8px;
  background: white;
  border-radius: 16px;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.15);
  padding: 16px;
  min-width: 280px;
  z-index: 100;
}

.quick-settings-panel .section {
  margin-bottom: 16px;
}

.quick-settings-panel .section-title {
  font-size: 12px;
  font-weight: 600;
  color: #666;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
}

/* 语言选择器 */
.language-selector {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 12px;
  background: #F2F2F7;
  border-radius: 10px;
  cursor: pointer;
  transition: background 0.2s;
}

.language-selector:hover {
  background: #E5E5EA;
}

.language-selector .arrow {
  margin-left: auto;
  color: #999;
}
```

---

## 附录

### A. 错误码定义

```typescript
enum TranslationErrorCode {
  // 客户端错误 (4xx)
  INVALID_REQUEST = 'T400001',
  UNSUPPORTED_LANGUAGE_PAIR = 'T400002',
  TEXT_TOO_LONG = 'T400003',
  RATE_LIMIT_EXCEEDED = 'T429001',

  // 服务端错误 (5xx)
  TRANSLATION_ENGINE_ERROR = 'T500001',
  ALL_ENGINES_FAILED = 'T500002',
  CACHE_ERROR = 'T500003',
  LANGUAGE_DETECTION_FAILED = 'T500004',

  // 网络错误
  TIMEOUT = 'T504001',
  NETWORK_ERROR = 'T503001',
}
```

### B. 支持的语言列表

```typescript
const supportedLanguages = [
  { code: 'zh-CN', name: '简体中文', flag: '🇨🇳' },
  { code: 'zh-TW', name: '繁體中文', flag: '🇹🇼' },
  { code: 'en', name: 'English', flag: '🇬🇧' },
  { code: 'en-US', name: 'English (US)', flag: '🇺🇸' },
  { code: 'ja', name: '日本語', flag: '🇯🇵' },
  { code: 'ko', name: '한국어', flag: '🇰🇷' },
  { code: 'fr', name: 'Français', flag: '🇫🇷' },
  { code: 'de', name: 'Deutsch', flag: '🇩🇪' },
  { code: 'es', name: 'Español', flag: '🇪🇸' },
  { code: 'ru', name: 'Русский', flag: '🇷🇺' },
  { code: 'ar', name: 'العربية', flag: '🇸🇦' },
  { code: 'pt', name: 'Português', flag: '🇵🇹' },
  { code: 'it', name: 'Italiano', flag: '🇮🇹' },
  { code: 'nl', name: 'Nederlands', flag: '🇳🇱' },
  { code: 'pl', name: 'Polski', flag: '🇵🇱' },
  { code: 'tr', name: 'Türkçe', flag: '🇹🇷' },
  { code: 'vi', name: 'Tiếng Việt', flag: '🇻🇳' },
  { code: 'th', name: 'ไทย', flag: '🇹🇭' },
  { code: 'id', name: 'Bahasa Indonesia', flag: '🇮🇩' },
  { code: 'ms', name: 'Bahasa Melayu', flag: '🇲🇾' },
  { code: 'hi', name: 'हिन्दी', flag: '🇮🇳' },
  { code: 'sv', name: 'Svenska', flag: '🇸🇪' },
  { code: 'da', name: 'Dansk', flag: '🇩🇰' },
  { code: 'fi', name: 'Suomi', flag: '🇫🇮' },
  { code: 'no', name: 'Norsk', flag: '🇳🇴' },
  { code: 'cs', name: 'Čeština', flag: '🇨🇿' },
  { code: 'el', name: 'Ελληνικά', flag: '🇬🇷' },
  { code: 'he', name: 'עברית', flag: '🇮🇱' },
  { code: 'uk', name: 'Українська', flag: '🇺🇦' },
];
```

### C. 配置示例

```yaml
# translation-service.yaml
service:
  name: translation-service
  port: 8080

translation:
  # 缓存配置
  cache:
    l1_ttl: 300  # 内存缓存5分钟
    l2_ttl: 604800  # Redis缓存7天
    l3_ttl: 2592000  # 数据库缓存30天

  # 引擎配置
  engines:
    primary: deepl
    fallback_order:
      - deepl
      - google_translate
      - azure_translator
      - local_onnx
    timeout_ms: 5000

  # 本地模型配置
  local:
    enabled: true
    model_path: /models/translation
    max_text_length: 100
    supported_pairs:
      - zh-en
      - en-zh
      - ja-en
      - en-ja

  # 质量阈值
  quality:
    min_acceptable_score: 0.7
    retry_threshold: 0.5

  # 流式翻译
  streaming:
    enabled: true
    buffer_size: 100
    sentence_delimiters: ['.', '!', '?', '。', '！', '？', '\n']

# 数据库连接
database:
  host: localhost
  port: 5432
  name: translation_db
  pool_size: 20

# Redis连接
redis:
  host: localhost
  port: 6379
  db: 0
```

---

## 版本历史

| 版本 | 日期 | 修改内容 |
|------|------|----------|
| 1.0 | 2024-01-15 | 初始版本 |
| 1.1 | 2024-02-20 | 增加学习模式详细设计 |
| 1.2 | 2024-03-10 | 优化缓存策略和流式翻译 |

---

*文档结束*
