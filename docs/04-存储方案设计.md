# 存储方案设计

本文档描述 Silly 项目的本地存储与云端同步方案设计，实现聊天记录本地化存储、云端备份、文件去重和加密保护。

## 1. 本地存储架构

### 1.1 目录结构设计

```
~/.silly/
├── config/
│   ├── settings.json          # 应用配置
│   └── cloud-providers.json   # 云端存储配置
├── data/
│   ├── database/
│   │   ├── silly.db           # 主数据库
│   │   ├── silly.db-wal       # WAL 文件
│   │   └── silly.db-shm       # 共享内存文件
│   ├── blobs/                 # 去重存储池（内部使用）
│   │   └── <hash-prefix>/
│   │       └── <hash>
│   ├── files/                 # 用户可见的自动整理文件夹
│   │   ├── images/            # 图片文件（按日期子文件夹）
│   │   │   └── 2026/
│   │   │       └── 02-23/
│   │   ├── videos/            # 视频文件
│   │   │   └── 2026/
│   │   │       └── 02-23/
│   │   ├── documents/         # 文档文件
│   │   │   └── 2026/
│   │   │       └── 02-23/
│   │   ├── audio/             # 音频文件
│   │   └── others/            # 其他类型
│   ├── cache/
│   │   ├── thumbnails/        # 缩略图缓存
│   │   ├── temp/              # 临时文件
│   │   └── sync/              # 同步缓存
│   └── backups/
│       └── <timestamp>/       # 本地备份
├── logs/
│   └── silly.log
└── lock/
    └── silly.lock
```

### 1.2 SQLite 数据库设计

#### 核心表结构

```sql
-- 数据库版本管理
CREATE TABLE schema_version (
    version INTEGER PRIMARY KEY,
    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    description TEXT
);

-- 会话表
CREATE TABLE conversations (
    id TEXT PRIMARY KEY,                    -- UUID v4
    title TEXT NOT NULL,
    model_id TEXT NOT NULL,                 -- 使用的AI模型
    system_prompt TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    archived_at TIMESTAMP,                  -- 归档时间
    metadata JSON                           -- 扩展元数据
);

-- 消息表
CREATE TABLE messages (
    id TEXT PRIMARY KEY,
    conversation_id TEXT NOT NULL,
    role TEXT NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
    content TEXT NOT NULL,
    tokens_used INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
);

-- 文件引用表
CREATE TABLE file_references (
    id TEXT PRIMARY KEY,
    message_id TEXT NOT NULL,
    blob_hash TEXT NOT NULL,                -- 关联的blob哈希
    file_name TEXT NOT NULL,                -- 原始文件名
    mime_type TEXT,
    file_size INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (message_id) REFERENCES messages(id) ON DELETE CASCADE,
    FOREIGN KEY (blob_hash) REFERENCES blobs(hash)
);

-- Blob存储池表
CREATE TABLE blobs (
    hash TEXT PRIMARY KEY,                  -- SHA-256哈希
    size INTEGER NOT NULL,
    mime_type TEXT,
    ref_count INTEGER DEFAULT 1,            -- 引用计数
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_accessed TIMESTAMP,
    storage_tier TEXT DEFAULT 'hot'         -- hot, warm, cold
);

-- 云端同步状态表
CREATE TABLE sync_status (
    id TEXT PRIMARY KEY,
    entity_type TEXT NOT NULL,              -- conversation, message, blob
    entity_id TEXT NOT NULL,
    provider_id TEXT NOT NULL,
    local_hash TEXT,                        -- 本地内容哈希
    remote_hash TEXT,                       -- 云端内容哈希
    local_modified_at TIMESTAMP,
    remote_modified_at TIMESTAMP,
    sync_state TEXT DEFAULT 'pending',      -- pending, synced, conflict, error
    last_sync_at TIMESTAMP,
    retry_count INTEGER DEFAULT 0,
    error_message TEXT,
    UNIQUE(entity_type, entity_id, provider_id)
);

-- 云端存储配置表
CREATE TABLE cloud_providers (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,                     -- 显示名称
    provider_type TEXT NOT NULL,            -- s3, oss, onedrive, webdav
    config JSON NOT NULL,                   -- 加密存储的配置
    is_enabled BOOLEAN DEFAULT 1,
    sync_enabled BOOLEAN DEFAULT 1,
    priority INTEGER DEFAULT 0,             -- 优先级，数值越小优先级越高
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_sync_at TIMESTAMP
);

-- 索引优化
CREATE INDEX idx_messages_conversation ON messages(conversation_id);
CREATE INDEX idx_messages_created ON messages(created_at);
CREATE INDEX idx_file_refs_blob ON file_references(blob_hash);
CREATE INDEX idx_file_refs_message ON file_references(message_id);
CREATE INDEX idx_sync_status_state ON sync_status(sync_state);
CREATE INDEX idx_sync_status_entity ON sync_status(entity_type, entity_id);
CREATE INDEX idx_blobs_refcount ON blobs(ref_count);
CREATE INDEX idx_blobs_tier ON blobs(storage_tier);
CREATE INDEX idx_conversations_updated ON conversations(updated_at);
```

### 1.3 文件存储池设计

#### Blob存储策略

```typescript
interface BlobStorageConfig {
  // 存储池根目录
  poolPath: string;

  // 哈希分片层级 (2层: ab/cd/abcdef...)
  shardLevels: number;

  // 每个分片目录的最大文件数
  maxFilesPerShard: number;

  // 存储池最大容量 (默认 10GB)
  maxPoolSize: number;

  // 自动清理阈值 (达到90%时触发)
  cleanupThreshold: number;
}

class BlobStorage {
  /**
   * 存储文件到Blob池
   * 1. 计算文件SHA-256哈希
   * 2. 检查是否已存在
   * 3. 不存在则复制到存储池
   * 4. 更新数据库引用计数
   */
  async store(filePath: string): Promise<string>;

  /**
   * 从Blob池读取文件
   * 更新最后访问时间
   */
  async read(hash: string): Promise<ReadableStream>;

  /**
   * 获取Blob的本地路径
   * 用于软连接或直接访问
   */
  getPath(hash: string): string;

  /**
   * 增加引用计数
   */
  async incrementRef(hash: string): Promise<void>;

  /**
   * 减少引用计数
   * 当ref_count为0时标记为可删除
   */
  async decrementRef(hash: string): Promise<void>;
}
```

#### 存储池路径计算

```typescript
function getBlobPath(hash: string): string {
  // hash: "a1b2c3d4e5f6..."
  // level1: "a1"
  // level2: "b2"
  // path: "~/.silly/data/blobs/a1/b2/a1b2c3d4e5f6..."

  const level1 = hash.substring(0, 2);
  const level2 = hash.substring(2, 4);

  return path.join(
    BLOB_POOL_PATH,
    level1,
    level2,
    hash
  );
}
```

## 2. 去重机制

### 2.1 文件哈希计算

```typescript
import { createHash } from 'crypto';
import { createReadStream } from 'fs';

interface HashResult {
  hash: string;           // SHA-256 hex
  size: number;
  mimeType: string;
}

class FileHasher {
  // 4MB 分块大小
  private readonly CHUNK_SIZE = 4 * 1024 * 1024;

  /**
   * 计算文件SHA-256哈希
   * 使用流式读取避免大文件内存问题
   */
  async hashFile(filePath: string): Promise<HashResult> {
    const hash = createHash('sha256');
    const stream = createReadStream(filePath, {
      highWaterMark: this.CHUNK_SIZE
    });

    let size = 0;

    for await (const chunk of stream) {
      hash.update(chunk);
      size += chunk.length;
    }

    return {
      hash: hash.digest('hex'),
      size,
      mimeType: await this.detectMimeType(filePath)
    };
  }

  /**
   * 快速哈希（用于大文件）
   * 采样文件头部、中部、尾部各1MB计算哈希
   */
  async hashFileFast(filePath: string): Promise<HashResult> {
    const { size } = await fs.stat(filePath);

    if (size <= 10 * 1024 * 1024) {
      // 小于10MB使用完整哈希
      return this.hashFile(filePath);
    }

    const hash = createHash('sha256');
    const sampleSize = 1024 * 1024; // 1MB

    // 读取头部
    const head = await fs.read(filePath, {
      length: sampleSize,
      position: 0
    });
    hash.update(head);

    // 读取中部
    const middlePos = Math.floor(size / 2);
    const middle = await fs.read(filePath, {
      length: sampleSize,
      position: middlePos
    });
    hash.update(middle);

    // 读取尾部
    const tailPos = size - sampleSize;
    const tail = await fs.read(filePath, {
      length: sampleSize,
      position: tailPos
    });
    hash.update(tail);

    // 添加文件大小到哈希计算
    hash.update(Buffer.from(size.toString()));

    return {
      hash: hash.digest('hex'),
      size,
      mimeType: await this.detectMimeType(filePath)
    };
  }

  private async detectMimeType(filePath: string): Promise<string> {
    // 使用 file-type 或 magic number 检测
    const fileType = await import('file-type');
    const result = await fileType.fromFile(filePath);
    return result?.mime || 'application/octet-stream';
  }
}
```

### 2.2 软连接实现

```typescript
import { symlink, unlink, stat, readlink } from 'fs/promises';
import { join, dirname, basename } from 'path';

interface LinkOptions {
  // 是否使用硬链接（同文件系统）
  useHardLink: boolean;

  // 是否使用符号链接（跨文件系统）
  useSymlink: boolean;

  // Windows下使用junction
  useJunction: boolean;
}

class DeduplicationManager {
  private blobStorage: BlobStorage;
  private fileHasher: FileHasher;

  /**
   * 存储文件，自动去重
   *
   * 流程：
   * 1. 计算文件哈希
   * 2. 查询数据库是否已存在
   * 3. 存在：增加引用计数，创建软连接
   * 4. 不存在：复制到存储池，创建记录
   */
  async storeFile(
    sourcePath: string,
    targetDir: string,
    options: LinkOptions
  ): Promise<FileReference> {
    // 1. 计算哈希
    const hashResult = await this.fileHasher.hashFile(sourcePath);

    // 2. 检查是否已存在
    const existingBlob = await this.getBlobByHash(hashResult.hash);

    if (existingBlob) {
      // 3. 已存在，增加引用计数
      await this.blobStorage.incrementRef(hashResult.hash);

      // 创建软连接到目标位置
      const targetPath = join(targetDir, basename(sourcePath));
      await this.createLink(existingBlob.path, targetPath, options);

      return {
        hash: hashResult.hash,
        path: targetPath,
        isDuplicate: true,
        refCount: existingBlob.refCount + 1
      };
    }

    // 4. 不存在，存储到Blob池
    await this.blobStorage.store(sourcePath);

    // 创建软连接
    const blobPath = this.blobStorage.getPath(hashResult.hash);
    const targetPath = join(targetDir, basename(sourcePath));
    await this.createLink(blobPath, targetPath, options);

    return {
      hash: hashResult.hash,
      path: targetPath,
      isDuplicate: false,
      refCount: 1
    };
  }

  /**
   * 创建链接
   * 优先使用硬链接，其次符号链接
   */
  private async createLink(
    source: string,
    target: string,
    options: LinkOptions
  ): Promise<void> {
    // 确保目标目录存在
    await fs.mkdir(dirname(target), { recursive: true });

    // 尝试硬链接（同文件系统，无额外空间占用）
    if (options.useHardLink) {
      try {
        await link(source, target);
        return;
      } catch (err) {
        // 跨文件系统，降级到软链接
      }
    }

    // 使用符号链接
    if (options.useSymlink) {
      await symlink(source, target, 'file');
      return;
    }

    // Windows junction（目录）
    if (options.useJunction && process.platform === 'win32') {
      await symlink(source, target, 'junction');
      return;
    }

    // 最后选择：复制文件
    await copyFile(source, target);
  }

  /**
   * 删除文件引用
   * 减少引用计数，当ref_count为0时删除Blob
   */
  async removeFileReference(hash: string, targetPath: string): Promise<void> {
    // 删除链接
    try {
      await unlink(targetPath);
    } catch (err) {
      // 链接可能已不存在
    }

    // 减少引用计数
    await this.blobStorage.decrementRef(hash);
  }
}
```

### 2.3 引用计数管理

```typescript
class ReferenceCounter {
  private db: Database;

  /**
   * 增加引用计数
   */
  async increment(hash: string): Promise<number> {
    const result = await this.db.run(
      `UPDATE blobs
       SET ref_count = ref_count + 1,
           last_accessed = CURRENT_TIMESTAMP
       WHERE hash = ?
       RETURNING ref_count`,
      [hash]
    );
    return result.ref_count;
  }

  /**
   * 减少引用计数
   * 当ref_count为0时，标记为待清理
   */
  async decrement(hash: string): Promise<number> {
    const result = await this.db.run(
      `UPDATE blobs
       SET ref_count = ref_count - 1,
           storage_tier = CASE
             WHEN ref_count - 1 = 0 THEN 'cold'
             ELSE storage_tier
           END
       WHERE hash = ?
       RETURNING ref_count`,
      [hash]
    );

    if (result.ref_count === 0) {
      // 触发清理检查
      await this.scheduleCleanup(hash);
    }

    return result.ref_count;
  }

  /**
   * 获取孤儿Blob（引用计数为0）
   */
  async getOrphanBlobs(limit: number = 100): Promise<string[]> {
    const rows = await this.db.all(
      `SELECT hash FROM blobs
       WHERE ref_count = 0
       AND storage_tier = 'cold'
       LIMIT ?`,
      [limit]
    );
    return rows.map(r => r.hash);
  }

  /**
   * 物理删除Blob
   */
  async deleteBlob(hash: string): Promise<void> {
    const blobPath = this.getBlobPath(hash);

    // 删除文件
    await fs.unlink(blobPath).catch(() => {});

    // 删除空目录
    const dir = dirname(blobPath);
    await this.removeEmptyDirs(dir);

    // 删除数据库记录
    await this.db.run('DELETE FROM blobs WHERE hash = ?', [hash]);
  }

  /**
   * 清理空目录
   */
  private async removeEmptyDirs(dir: string): Promise<void> {
    try {
      const entries = await fs.readdir(dir);
      if (entries.length === 0) {
        await fs.rmdir(dir);
        // 递归检查父目录
        await this.removeEmptyDirs(dirname(dir));
      }
    } catch (err) {
      // 忽略错误
    }
  }
}
```

## 3. 云端存储集成

### 3.1 支持的云服务

```typescript
// 云端存储类型枚举
enum CloudProviderType {
  S3 = 's3',           // AWS S3 兼容
  OSS = 'oss',         // 阿里云OSS
  ONEDRIVE = 'onedrive',
  WEBDAV = 'webdav',
  GOOGLE_DRIVE = 'google_drive',
  DROPBOX = 'dropbox'
}

// 统一配置接口
interface CloudProviderConfig {
  id: string;
  name: string;
  type: CloudProviderType;
  enabled: boolean;
  syncEnabled: boolean;
  priority: number;

  // 加密存储的凭证
  credentials: EncryptedCredentials;

  // 同步设置
  syncSettings: SyncSettings;
}

// S3/OSS 配置
interface S3Config {
  endpoint: string;
  region: string;
  bucket: string;
  accessKeyId: string;
  secretAccessKey: string;

  // 高级选项
  useSSL: boolean;
  forcePathStyle: boolean;  // 用于MinIO等私有部署

  // 存储路径前缀
  prefix: string;
}

// OneDrive 配置
interface OneDriveConfig {
  clientId: string;
  clientSecret: string;
  refreshToken: string;

  // 存储路径
  folderPath: string;
}

// WebDAV 配置
interface WebDAVConfig {
  url: string;
  username: string;
  password: string;

  // 存储路径
  basePath: string;
}

// 同步设置
interface SyncSettings {
  // 自动同步间隔（分钟，0表示手动）
  autoSyncInterval: number;

  // 同步范围
  syncConversations: boolean;
  syncFiles: boolean;
  syncSettings: boolean;

  // 带宽限制 (KB/s, 0表示无限制)
  bandwidthLimit: number;

  // 冲突解决策略
  conflictResolution: 'local' | 'remote' | 'newest' | 'manual';

  // 加密设置
  encryption: {
    enabled: boolean;
    algorithm: 'aes-256-gcm';
    keyDerivation: 'pbkdf2' | 'argon2';
  };
}
```

### 3.2 配置接口设计

```typescript
// 云端存储管理器
class CloudStorageManager {
  private providers: Map<string, CloudProvider>;
  private db: Database;

  /**
   * 添加云端存储配置
   */
  async addProvider(config: CloudProviderConfig): Promise<string> {
    // 加密凭证
    const encryptedCreds = await this.encryptCredentials(config.credentials);

    // 验证连接
    const provider = this.createProvider(config.type, config.credentials);
    await provider.testConnection();

    // 保存到数据库
    const id = generateUUID();
    await this.db.run(
      `INSERT INTO cloud_providers (id, name, provider_type, config, is_enabled, sync_enabled, priority)
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [
        id,
        config.name,
        config.type,
        JSON.stringify({
          ...config,
          credentials: encryptedCreds
        }),
        config.enabled,
        config.syncEnabled,
        config.priority
      ]
    );

    return id;
  }

  /**
   * 更新配置
   */
  async updateProvider(
    id: string,
    updates: Partial<CloudProviderConfig>
  ): Promise<void> {
    const provider = await this.getProvider(id);
    const newConfig = { ...provider, ...updates };

    if (updates.credentials) {
      newConfig.credentials = await this.encryptCredentials(updates.credentials);
    }

    await this.db.run(
      `UPDATE cloud_providers
       SET config = ?, is_enabled = ?, sync_enabled = ?, priority = ?
       WHERE id = ?`,
      [
        JSON.stringify(newConfig),
        newConfig.enabled,
        newConfig.syncEnabled,
        newConfig.priority,
        id
      ]
    );
  }

  /**
   * 删除配置
   */
  async removeProvider(id: string): Promise<void> {
    // 删除同步状态记录
    await this.db.run(
      'DELETE FROM sync_status WHERE provider_id = ?',
      [id]
    );

    // 删除配置
    await this.db.run(
      'DELETE FROM cloud_providers WHERE id = ?',
      [id]
    );

    this.providers.delete(id);
  }

  /**
   * 获取所有配置
   */
  async listProviders(): Promise<CloudProviderInfo[]> {
    const rows = await this.db.all(
      `SELECT id, name, provider_type, is_enabled, sync_enabled, priority, last_sync_at
       FROM cloud_providers
       ORDER BY priority ASC`
    );

    return rows.map(row => ({
      id: row.id,
      name: row.name,
      type: row.provider_type,
      enabled: row.is_enabled,
      syncEnabled: row.sync_enabled,
      priority: row.priority,
      lastSyncAt: row.last_sync_at
    }));
  }

  /**
   * 凭证加密
   */
  private async encryptCredentials(creds: any): Promise<string> {
    const masterKey = await this.getMasterKey();
    return encryptAES(JSON.stringify(creds), masterKey);
  }

  /**
   * 凭证解密
   */
  private async decryptCredentials(encrypted: string): Promise<any> {
    const masterKey = await this.getMasterKey();
    return JSON.parse(decryptAES(encrypted, masterKey));
  }
}
```

### 3.3 同步策略

```typescript
// 同步管理器
class SyncManager {
  private cloudManager: CloudStorageManager;
  private db: Database;
  private syncQueue: PQueue;  // 使用p-queue控制并发

  constructor() {
    // 限制并发数为3
    this.syncQueue = new PQueue({ concurrency: 3 });
  }

  /**
   * 执行完整同步
   */
  async syncAll(providerId?: string): Promise<SyncResult> {
    const providers = providerId
      ? [await this.cloudManager.getProvider(providerId)]
      : await this.cloudManager.getEnabledProviders();

    const results: SyncResult[] = [];

    for (const provider of providers) {
      const result = await this.syncProvider(provider);
      results.push(result);
    }

    return this.mergeResults(results);
  }

  /**
   * 同步单个提供商
   */
  private async syncProvider(provider: CloudProvider): Promise<SyncResult> {
    const result: SyncResult = {
      uploaded: 0,
      downloaded: 0,
      conflicts: 0,
      errors: [],
      startTime: Date.now()
    };

    try {
      // 1. 同步数据库
      await this.syncDatabase(provider, result);

      // 2. 同步文件
      await this.syncFiles(provider, result);

      // 3. 解决冲突
      await this.resolveConflicts(provider, result);

      // 4. 更新同步时间
      await this.updateLastSync(provider.id);

    } catch (err) {
      result.errors.push({
        type: 'fatal',
        message: err.message
      });
    }

    result.endTime = Date.now();
    return result;
  }

  /**
   * 同步数据库（增量同步）
   */
  private async syncDatabase(
    provider: CloudProvider,
    result: SyncResult
  ): Promise<void> {
    // 获取上次同步时间
    const lastSync = await this.getLastSync(provider.id);

    // 获取本地变更
    const localChanges = await this.getLocalChanges(lastSync);

    // 获取远程变更
    const remoteChanges = await provider.listChanges(lastSync);

    // 上传本地变更
    for (const change of localChanges) {
      await this.syncQueue.add(async () => {
        try {
          await this.uploadEntity(provider, change);
          result.uploaded++;
        } catch (err) {
          result.errors.push({
            type: 'upload',
            entity: change.id,
            message: err.message
          });
        }
      });
    }

    // 下载远程变更
    for (const change of remoteChanges) {
      await this.syncQueue.add(async () => {
        try {
          await this.downloadEntity(provider, change);
          result.downloaded++;
        } catch (err) {
          result.errors.push({
            type: 'download',
            entity: change.id,
            message: err.message
          });
        }
      });
    }

    await this.syncQueue.onIdle();
  }

  /**
   * 同步文件
   */
  private async syncFiles(
    provider: CloudProvider,
    result: SyncResult
  ): Promise<void> {
    // 获取需要同步的文件列表
    const filesToSync = await this.db.all(
      `SELECT b.hash, b.size
       FROM blobs b
       JOIN sync_status s ON s.entity_id = b.hash
       WHERE s.provider_id = ?
       AND s.entity_type = 'blob'
       AND s.sync_state = 'pending'`,
      [provider.id]
    );

    for (const file of filesToSync) {
      await this.syncQueue.add(async () => {
        try {
          const blobPath = this.blobStorage.getPath(file.hash);

          // 检查远程是否存在
          const exists = await provider.exists(`blobs/${file.hash}`);

          if (!exists) {
            // 上传文件
            await provider.upload(
              blobPath,
              `blobs/${file.hash}`,
              {
                contentType: 'application/octet-stream',
                metadata: { hash: file.hash, size: file.size }
              }
            );

            await this.updateSyncStatus(provider.id, 'blob', file.hash, 'synced');
            result.uploaded++;
          }
        } catch (err) {
          await this.updateSyncStatus(provider.id, 'blob', file.hash, 'error', err.message);
          result.errors.push({
            type: 'file_upload',
            entity: file.hash,
            message: err.message
          });
        }
      });
    }

    await this.syncQueue.onIdle();
  }

  /**
   * 冲突检测与解决
   */
  private async resolveConflicts(
    provider: CloudProvider,
    result: SyncResult
  ): Promise<void> {
    const conflicts = await this.db.all(
      `SELECT * FROM sync_status
       WHERE provider_id = ?
       AND sync_state = 'conflict'`,
      [provider.id]
    );

    for (const conflict of conflicts) {
      const resolution = await this.resolveConflict(conflict, provider);

      switch (resolution) {
        case 'local':
          await this.uploadEntity(provider, conflict);
          break;
        case 'remote':
          await this.downloadEntity(provider, conflict);
          break;
        case 'merge':
          await this.mergeEntities(provider, conflict);
          break;
      }

      result.conflicts++;
    }
  }

  /**
   * 自动同步调度
   */
  startAutoSync(): void {
    setInterval(async () => {
      const providers = await this.cloudManager.getEnabledProviders();

      for (const provider of providers) {
        const config = await this.cloudManager.getConfig(provider.id);

        if (config.syncSettings.autoSyncInterval > 0) {
          const lastSync = await this.getLastSync(provider.id);
          const nextSync = lastSync + config.syncSettings.autoSyncInterval * 60 * 1000;

          if (Date.now() >= nextSync) {
            await this.syncProvider(provider);
          }
        }
      }
    }, 60000); // 每分钟检查一次
  }
}

// 同步结果
interface SyncResult {
  uploaded: number;
  downloaded: number;
  conflicts: number;
  errors: SyncError[];
  startTime: number;
  endTime?: number;
}

interface SyncError {
  type: string;
  entity?: string;
  message: string;
}
```

## 4. 加密方案

### 4.1 本地加密

```typescript
import { createCipheriv, createDecipheriv, randomBytes, scryptSync } from 'crypto';

// 加密配置
const ENCRYPTION_CONFIG = {
  algorithm: 'aes-256-gcm',
  keyLength: 32,
  ivLength: 16,
  authTagLength: 16,
  saltLength: 32,
  iterations: 100000
};

class LocalEncryption {
  private masterKey: Buffer | null = null;

  /**
   * 初始化主密钥
   * 从系统密钥环获取或使用密码派生
   */
  async initializeMasterKey(password?: string): Promise<void> {
    // 尝试从系统密钥环获取
    const keyring = await import('keytar');
    let key = await keyring.getPassword('silly', 'master-key');

    if (!key && password) {
      // 从密码派生
      const salt = randomBytes(ENCRYPTION_CONFIG.saltLength);
      const derivedKey = scryptSync(
        password,
        salt,
        ENCRYPTION_CONFIG.keyLength,
        { N: 16384, r: 8, p: 1 }
      );

      // 存储到密钥环
      await keyring.setPassword('silly', 'master-key', derivedKey.toString('base64'));
      key = derivedKey.toString('base64');
    }

    if (!key) {
      throw new Error('Master key not found and no password provided');
    }

    this.masterKey = Buffer.from(key, 'base64');
  }

  /**
   * 加密数据
   */
  encrypt(plaintext: string | Buffer): EncryptedData {
    if (!this.masterKey) {
      throw new Error('Master key not initialized');
    }

    const iv = randomBytes(ENCRYPTION_CONFIG.ivLength);
    const cipher = createCipheriv(
      ENCRYPTION_CONFIG.algorithm,
      this.masterKey,
      iv,
      { authTagLength: ENCRYPTION_CONFIG.authTagLength }
    );

    const data = Buffer.isBuffer(plaintext) ? plaintext : Buffer.from(plaintext, 'utf8');
    const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);
    const authTag = cipher.getAuthTag();

    return {
      iv: iv.toString('base64'),
      data: encrypted.toString('base64'),
      authTag: authTag.toString('base64'),
      algorithm: ENCRYPTION_CONFIG.algorithm
    };
  }

  /**
   * 解密数据
   */
  decrypt(encrypted: EncryptedData): Buffer {
    if (!this.masterKey) {
      throw new Error('Master key not initialized');
    }

    const decipher = createDecipheriv(
      encrypted.algorithm,
      this.masterKey,
      Buffer.from(encrypted.iv, 'base64'),
      { authTagLength: ENCRYPTION_CONFIG.authTagLength }
    );

    decipher.setAuthTag(Buffer.from(encrypted.authTag, 'base64'));

    return Buffer.concat([
      decipher.update(Buffer.from(encrypted.data, 'base64')),
      decipher.final()
    ]);
  }

  /**
   * 加密文件
   */
  async encryptFile(inputPath: string, outputPath: string): Promise<void> {
    const fs = await import('fs/promises');
    const data = await fs.readFile(inputPath);
    const encrypted = this.encrypt(data);

    await fs.writeFile(outputPath, JSON.stringify(encrypted));
  }

  /**
   * 解密文件
   */
  async decryptFile(inputPath: string, outputPath: string): Promise<void> {
    const fs = await import('fs/promises');
    const content = await fs.readFile(inputPath, 'utf8');
    const encrypted: EncryptedData = JSON.parse(content);
    const decrypted = this.decrypt(encrypted);

    await fs.writeFile(outputPath, decrypted);
  }
}

interface EncryptedData {
  iv: string;
  data: string;
  authTag: string;
  algorithm: string;
}
```

### 4.2 传输加密

```typescript
class TransportEncryption {
  /**
   * 建立安全传输通道
   * 使用TLS 1.3，对于不支持的服务使用额外加密层
   */

  /**
   * 端到端加密上传
   * 在TLS之上增加应用层加密
   */
  async encryptAndUpload(
    provider: CloudProvider,
    filePath: string,
    remotePath: string,
    encryptionKey: Buffer
  ): Promise<void> {
    // 1. 生成文件加密密钥
    const fileKey = randomBytes(32);
    const iv = randomBytes(16);

    // 2. 使用文件密钥加密文件
    const cipher = createCipheriv('aes-256-gcm', fileKey, iv);
    const fs = await import('fs');
    const readStream = fs.createReadStream(filePath);

    // 3. 使用提供商公钥加密文件密钥
    const encryptedKey = await this.encryptKey(fileKey, provider.publicKey);

    // 4. 上传加密后的文件和密钥
    const uploadStream = readStream.pipe(cipher);

    await provider.uploadStream(uploadStream, remotePath, {
      metadata: {
        'x-encrypted': 'true',
        'x-encrypted-key': encryptedKey.toString('base64'),
        'x-iv': iv.toString('base64')
      }
    });
  }

  /**
   * 密钥封装
   * 使用RSA-OAEP或ECIES封装文件加密密钥
   */
  private async encryptKey(key: Buffer, publicKey: Buffer): Promise<Buffer> {
    const { publicEncrypt } = await import('crypto');
    return publicEncrypt(
      {
        key: publicKey,
        padding: constants.RSA_PKCS1_OAEP_PADDING,
        oaepHash: 'sha256'
      },
      key
    );
  }
}
```

### 4.3 云端加密

```typescript
class CloudEncryption {
  private localEncryption: LocalEncryption;

  /**
   * 客户端加密方案
   * 数据在离开客户端前加密，云端只存储密文
   */

  /**
   * 加密上传数据库
   */
  async encryptDatabaseForCloud(dbPath: string): Promise<string> {
    // 1. 创建数据库临时副本
    const tempPath = `${dbPath}.tmp`;
    await copyFile(dbPath, tempPath);

    // 2. 压缩
    const compressedPath = `${tempPath}.gz`;
    await this.compress(tempPath, compressedPath);

    // 3. 加密
    const encryptedPath = `${compressedPath}.enc`;
    await this.localEncryption.encryptFile(compressedPath, encryptedPath);

    // 4. 清理临时文件
    await unlink(tempPath);
    await unlink(compressedPath);

    return encryptedPath;
  }

  /**
   * 解密从云端下载的数据库
   */
  async decryptDatabaseFromCloud(
    encryptedPath: string,
    outputPath: string
  ): Promise<void> {
    // 1. 解密
    const decryptedPath = `${encryptedPath}.dec`;
    await this.localEncryption.decryptFile(encryptedPath, decryptedPath);

    // 2. 解压
    await this.decompress(decryptedPath, outputPath);

    // 3. 清理
    await unlink(decryptedPath);
  }

  /**
   * 流式加密大文件
   */
  createEncryptStream(key: Buffer, iv: Buffer): Transform {
    const cipher = createCipheriv('aes-256-gcm', key, iv);

    return new Transform({
      transform(chunk, encoding, callback) {
        try {
          const encrypted = cipher.update(chunk);
          callback(null, encrypted);
        } catch (err) {
          callback(err);
        }
      },
      flush(callback) {
        try {
          const final = cipher.final();
          const authTag = cipher.getAuthTag();
          callback(null, Buffer.concat([final, authTag]));
        } catch (err) {
          callback(err);
        }
      }
    });
  }

  /**
   * 生成加密元数据
   */
  generateEncryptionMetadata(): EncryptionMetadata {
    return {
      algorithm: 'aes-256-gcm',
      key: randomBytes(32).toString('base64'),
      iv: randomBytes(16).toString('base64'),
      version: 1
    };
  }
}

interface EncryptionMetadata {
  algorithm: string;
  key: string;
  iv: string;
  version: number;
}
```

## 5. 存储管理

### 5.1 清理策略

```typescript
class StorageCleanup {
  private db: Database;
  private blobStorage: BlobStorage;

  /**
   * 清理配置
   */
  private readonly config = {
    // 临时文件保留时间（小时）
    tempFileRetention: 24,

    // 孤儿Blob保留时间（天）
    orphanBlobRetention: 7,

    // 缓存大小限制 (MB)
    cacheSizeLimit: 500,

    // 存储池大小限制 (GB)
    poolSizeLimit: 10,

    // 存储池清理阈值 (%)
    poolCleanupThreshold: 90
  };

  /**
   * 执行清理任务
   */
  async cleanup(): Promise<CleanupResult> {
    const result: CleanupResult = {
      tempFilesRemoved: 0,
      orphanBlobsRemoved: 0,
      cacheCleared: 0,
      spaceReclaimed: 0
    };

    // 1. 清理临时文件
    const tempResult = await this.cleanupTempFiles();
    result.tempFilesRemoved = tempResult.count;
    result.spaceReclaimed += tempResult.space;

    // 2. 清理孤儿Blob
    const orphanResult = await this.cleanupOrphanBlobs();
    result.orphanBlobsRemoved = orphanResult.count;
    result.spaceReclaimed += orphanResult.space;

    // 3. 清理缓存
    const cacheResult = await this.cleanupCache();
    result.cacheCleared = cacheResult.space;
    result.spaceReclaimed += cacheResult.space;

    // 4. 检查存储池容量
    await this.checkPoolCapacity();

    return result;
  }

  /**
   * 清理临时文件
   */
  private async cleanupTempFiles(): Promise<CleanupItemResult> {
    const tempDir = '~/.silly/data/cache/temp';
    const cutoffTime = Date.now() - this.config.tempFileRetention * 3600 * 1000;

    let count = 0;
    let space = 0;

    const files = await this.listFilesRecursive(tempDir);

    for (const file of files) {
      const stat = await fs.stat(file);

      if (stat.mtime.getTime() < cutoffTime) {
        space += stat.size;
        await fs.unlink(file);
        count++;
      }
    }

    return { count, space };
  }

  /**
   * 清理孤儿Blob
   */
  private async cleanupOrphanBlobs(): Promise<CleanupItemResult> {
    const cutoffTime = Date.now() - this.config.orphanBlobRetention * 24 * 3600 * 1000;

    const orphans = await this.db.all(
      `SELECT hash, size FROM blobs
       WHERE ref_count = 0
       AND storage_tier = 'cold'
       AND created_at < datetime(?, 'unixepoch')`,
      [cutoffTime / 1000]
    );

    let count = 0;
    let space = 0;

    for (const orphan of orphans) {
      try {
        await this.blobStorage.deleteBlob(orphan.hash);
        space += orphan.size;
        count++;
      } catch (err) {
        console.error(`Failed to delete orphan blob ${orphan.hash}:`, err);
      }
    }

    return { count, space };
  }

  /**
   * 清理缓存
   */
  private async cleanupCache(): Promise<{ space: number }> {
    const cacheDir = '~/.silly/data/cache';
    const cacheSize = await this.calculateDirSize(cacheDir);
    const limit = this.config.cacheSizeLimit * 1024 * 1024;

    if (cacheSize <= limit) {
      return { space: 0 };
    }

    // LRU清理：按访问时间排序，删除最旧的
    const files = await this.getCacheFilesSortedByAccess();
    let spaceToFree = cacheSize - limit;
    let spaceFreed = 0;

    for (const file of files) {
      if (spaceFreed >= spaceToFree) break;

      try {
        const stat = await fs.stat(file);
        await fs.unlink(file);
        spaceFreed += stat.size;
      } catch (err) {
        // 忽略错误
      }
    }

    return { space: spaceFreed };
  }

  /**
   * 检查存储池容量
   */
  private async checkPoolCapacity(): Promise<void> {
    const poolSize = await this.calculateDirSize('~/.silly/data/blobs');
    const limit = this.config.poolSizeLimit * 1024 * 1024 * 1024;
    const threshold = limit * (this.config.poolCleanupThreshold / 100);

    if (poolSize > threshold) {
      // 触发LRU清理
      await this.cleanupByLRU(poolSize - threshold);
    }
  }

  /**
   * LRU清理
   */
  private async cleanupByLRU(spaceToFree: number): Promise<void> {
    // 获取按最后访问时间排序的Blob
    const blobs = await this.db.all(
      `SELECT hash, size FROM blobs
       WHERE storage_tier = 'hot'
       ORDER BY last_accessed ASC
       LIMIT 1000`
    );

    let spaceFreed = 0;

    for (const blob of blobs) {
      if (spaceFreed >= spaceToFree) break;

      // 只清理引用数低的文件
      if (blob.ref_count <= 1) {
        await this.db.run(
          "UPDATE blobs SET storage_tier = 'warm' WHERE hash = ?",
          [blob.hash]
        );
        spaceFreed += blob.size;
      }
    }
  }

  /**
   * 调度定期清理
   */
  scheduleCleanup(): void {
    // 每天凌晨3点执行清理
    const schedule = require('node-schedule');
    schedule.scheduleJob('0 3 * * *', () => {
      this.cleanup().then(result => {
        console.log('Cleanup completed:', result);
      }).catch(err => {
        console.error('Cleanup failed:', err);
      });
    });
  }
}

interface CleanupResult {
  tempFilesRemoved: number;
  orphanBlobsRemoved: number;
  cacheCleared: number;
  spaceReclaimed: number;
}

interface CleanupItemResult {
  count: number;
  space: number;
}
```

### 5.2 归档策略

```typescript
class ArchiveManager {
  private db: Database;

  /**
   * 归档配置
   */
  private readonly config = {
    // 自动归档时间（天）
    autoArchiveDays: 90,

    // 归档压缩级别
    compressionLevel: 6,

    // 本地归档路径
    localArchivePath: '~/.silly/data/archives',

    // 云端归档路径前缀
    cloudArchivePrefix: 'archives'
  };

  /**
   * 归档旧的会话
   */
  async archiveOldConversations(): Promise<ArchiveResult> {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - this.config.autoArchiveDays);

    // 查找需要归档的会话
    const conversations = await this.db.all(
      `SELECT * FROM conversations
       WHERE updated_at < ?
       AND archived_at IS NULL`,
      [cutoffDate.toISOString()]
    );

    const result: ArchiveResult = {
      archived: 0,
      errors: []
    };

    for (const conv of conversations) {
      try {
        await this.archiveConversation(conv.id);
        result.archived++;
      } catch (err) {
        result.errors.push({
          conversationId: conv.id,
          error: err.message
        });
      }
    }

    return result;
  }

  /**
   * 归档单个会话
   */
  private async archiveConversation(conversationId: string): Promise<void> {
    // 1. 导出会话数据
    const conversation = await this.exportConversation(conversationId);

    // 2. 压缩
    const archivePath = await this.compressConversation(conversation);

    // 3. 加密
    const encryptedPath = await this.encryptArchive(archivePath);

    // 4. 上传到云端（如果配置了）
    await this.uploadToCloud(encryptedPath, conversationId);

    // 5. 标记为已归档
    await this.db.run(
      `UPDATE conversations
       SET archived_at = CURRENT_TIMESTAMP
       WHERE id = ?`,
      [conversationId]
    );

    // 6. 清理本地数据（可选）
    await this.cleanupArchivedData(conversationId);
  }

  /**
   * 导出会话数据
   */
  private async exportConversation(conversationId: string): Promise<ConversationExport> {
    const conversation = await this.db.get(
      'SELECT * FROM conversations WHERE id = ?',
      [conversationId]
    );

    const messages = await this.db.all(
      'SELECT * FROM messages WHERE conversation_id = ? ORDER BY created_at',
      [conversationId]
    );

    const files = await this.db.all(
      `SELECT f.*, b.hash, b.size
       FROM file_references f
       JOIN blobs b ON f.blob_hash = b.hash
       WHERE f.message_id IN (SELECT id FROM messages WHERE conversation_id = ?)`,
      [conversationId]
    );

    return {
      version: 1,
      exportedAt: new Date().toISOString(),
      conversation,
      messages,
      files
    };
  }

  /**
   * 压缩会话数据
   */
  private async compressConversation(data: ConversationExport): Promise<string> {
    const archiver = require('archiver');
    const archive = archiver('zip', { zlib: { level: this.config.compressionLevel } });

    const archiveName = `conversation_${data.conversation.id}_${Date.now()}.zip`;
    const archivePath = path.join(this.config.localArchivePath, archiveName);

    const output = fs.createWriteStream(archivePath);
    archive.pipe(output);

    // 添加元数据
    archive.append(JSON.stringify(data, null, 2), { name: 'metadata.json' });

    // 添加关联文件
    for (const file of data.files) {
      const blobPath = this.blobStorage.getPath(file.blob_hash);
      if (await fs.access(blobPath).then(() => true).catch(() => false)) {
        archive.file(blobPath, { name: `files/${file.file_name}` });
      }
    }

    await archive.finalize();

    return new Promise((resolve, reject) => {
      output.on('close', () => resolve(archivePath));
      archive.on('error', reject);
    });
  }

  /**
   * 从归档恢复会话
   */
  async restoreFromArchive(archivePath: string): Promise<string> {
    const extract = require('extract-zip');
    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'silly-restore-'));

    try {
      // 1. 解压
      await extract(archivePath, { dir: tempDir });

      // 2. 读取元数据
      const metadataPath = path.join(tempDir, 'metadata.json');
      const data: ConversationExport = JSON.parse(
        await fs.readFile(metadataPath, 'utf8')
      );

      // 3. 恢复会话
      const newId = await this.importConversation(data);

      // 4. 恢复文件
      const filesDir = path.join(tempDir, 'files');
      for (const file of data.files) {
        const sourcePath = path.join(filesDir, file.file_name);
        if (await fs.access(sourcePath).then(() => true).catch(() => false)) {
          await this.blobStorage.store(sourcePath);
        }
      }

      return newId;
    } finally {
      // 清理临时目录
      await fs.rm(tempDir, { recursive: true, force: true });
    }
  }

  /**
   * 清理已归档的本地数据
   */
  private async cleanupArchivedData(conversationId: string): Promise<void> {
    // 删除消息内容（保留元数据）
    await this.db.run(
      `UPDATE messages SET content = '[archived]'
       WHERE conversation_id = ?`,
      [conversationId]
    );

    // 减少文件引用计数
    const files = await this.db.all(
      `SELECT blob_hash FROM file_references
       WHERE message_id IN (SELECT id FROM messages WHERE conversation_id = ?)`,
      [conversationId]
    );

    for (const file of files) {
      await this.blobStorage.decrementRef(file.blob_hash);
    }
  }
}

interface ArchiveResult {
  archived: number;
  errors: Array<{ conversationId: string; error: string }>;
}

interface ConversationExport {
  version: number;
  exportedAt: string;
  conversation: any;
  messages: any[];
  files: any[];
}
```

## 6. 文件自动整理机制

### 6.1 自动整理架构

核心引擎自动将对话中的图片、视频、文档等文件整理到本地对应文件夹，通过软连接机制保证本机不会有重复性文件产生。

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           文件自动整理流程                                     │
└─────────────────────────────────────────────────────────────────────────────┘

对话消息中的文件
       │
       ▼
┌───────────────┐     ┌───────────────┐     ┌───────────────┐
│  文件类型识别  │────►│  计算内容哈希  │────►│  查重检测     │
│  (MIME类型)   │     │  (SHA-256)   │     │  (Blob池)     │
└───────────────┘     └───────────────┘     └───────┬───────┘
                                                    │
                            ┌───────────────────────┴───────────────────────┐
                            ▼                                               ▼
                    ┌───────────────┐                               ┌───────────────┐
                    │   文件已存在   │                               │   新文件      │
                    │   (重复文件)   │                               │               │
                    └───────┬───────┘                               └───────┬───────┘
                            │                                               │
                            ▼                                               ▼
                    ┌───────────────┐                               ┌───────────────┐
                    │  增加引用计数  │                               │  存入Blob池   │
                    │               │                               │               │
                    └───────┬───────┘                               └───────┬───────┘
                            │                                               │
                            └───────────────────┬───────────────────────────┘
                                                │
                                                ▼
                                        ┌───────────────┐
                                        │  创建分类软连接 │
                                        │               │
                                        └───────┬───────┘
                                                │
                    ┌───────────────────────────┼───────────────────────────┐
                    │                           │                           │
                    ▼                           ▼                           ▼
            ┌───────────────┐          ┌───────────────┐          ┌───────────────┐
            │  images/      │          │  videos/      │          │ documents/    │
            │  (图片文件)    │          │  (视频文件)    │          │  (文档文件)    │
            └───────────────┘          └───────────────┘          └───────────────┘
```

### 6.2 文件分类规则

```typescript
// 文件类型分类器
interface FileClassifier {
  // 分类结果
  category: FileCategory;
  // 子分类（年份/月份）
  subPath: string;
  // 是否支持预览
  previewable: boolean;
  // 缩略图生成策略
  thumbnailStrategy: ThumbnailStrategy;
}

// 文件分类枚举
enum FileCategory {
  IMAGES = 'images',        // 图片
  VIDEOS = 'videos',        // 视频
  DOCUMENTS = 'documents',  // 文档
  AUDIO = 'audio',          // 音频
  ARCHIVES = 'archives',    // 压缩包
  OTHERS = 'others'         // 其他
}

// MIME类型到分类的映射
const MIME_TYPE_MAPPING: Record<string, FileCategory> = {
  // 图片
  'image/jpeg': FileCategory.IMAGES,
  'image/png': FileCategory.IMAGES,
  'image/gif': FileCategory.IMAGES,
  'image/webp': FileCategory.IMAGES,
  'image/svg+xml': FileCategory.IMAGES,
  'image/heic': FileCategory.IMAGES,

  // 视频
  'video/mp4': FileCategory.VIDEOS,
  'video/webm': FileCategory.VIDEOS,
  'video/quicktime': FileCategory.VIDEOS,
  'video/x-msvideo': FileCategory.VIDEOS,

  // 文档
  'application/pdf': FileCategory.DOCUMENTS,
  'application/msword': FileCategory.DOCUMENTS,
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document': FileCategory.DOCUMENTS,
  'application/vnd.ms-excel': FileCategory.DOCUMENTS,
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': FileCategory.DOCUMENTS,
  'application/vnd.ms-powerpoint': FileCategory.DOCUMENTS,
  'application/vnd.openxmlformats-officedocument.presentationml.presentation': FileCategory.DOCUMENTS,
  'text/plain': FileCategory.DOCUMENTS,
  'text/markdown': FileCategory.DOCUMENTS,
  'text/csv': FileCategory.DOCUMENTS,

  // 音频
  'audio/mpeg': FileCategory.AUDIO,
  'audio/wav': FileCategory.AUDIO,
  'audio/ogg': FileCategory.AUDIO,
  'audio/aac': FileCategory.AUDIO,

  // 压缩包
  'application/zip': FileCategory.ARCHIVES,
  'application/x-rar-compressed': FileCategory.ARCHIVES,
  'application/x-7z-compressed': FileCategory.ARCHIVES,
  'application/gzip': FileCategory.ARCHIVES
};

// 文件分类器实现
class SmartFileClassifier {
  /**
   * 对文件进行分类
   */
  async classify(file: FileInfo): Promise<FileClassifier> {
    const category = this.detectCategory(file);
    const date = file.createdAt || new Date();
    const subPath = this.generateSubPath(date);

    return {
      category,
      subPath,
      previewable: this.isPreviewable(category, file.mimeType),
      thumbnailStrategy: this.getThumbnailStrategy(category, file)
    };
  }

  /**
   * 检测文件分类
   */
  private detectCategory(file: FileInfo): FileCategory {
    // 1. 优先使用MIME类型
    if (file.mimeType && MIME_TYPE_MAPPING[file.mimeType]) {
      return MIME_TYPE_MAPPING[file.mimeType];
    }

    // 2. 通过文件扩展名推断
    const ext = file.name.split('.').pop()?.toLowerCase();
    if (ext) {
      return this.inferCategoryFromExtension(ext);
    }

    // 3. 文件头魔数检测
    return this.detectByMagicNumber(file.path);
  }

  /**
   * 通过扩展名推断类型
   */
  private inferCategoryFromExtension(ext: string): FileCategory {
    const imageExts = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg', 'heic', 'raw'];
    const videoExts = ['mp4', 'webm', 'mov', 'avi', 'mkv', 'flv', 'wmv'];
    const docExts = ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'txt', 'md', 'csv'];
    const audioExts = ['mp3', 'wav', 'ogg', 'aac', 'flac', 'm4a'];
    const archiveExts = ['zip', 'rar', '7z', 'tar', 'gz', 'bz2'];

    if (imageExts.includes(ext)) return FileCategory.IMAGES;
    if (videoExts.includes(ext)) return FileCategory.VIDEOS;
    if (docExts.includes(ext)) return FileCategory.DOCUMENTS;
    if (audioExts.includes(ext)) return FileCategory.AUDIO;
    if (archiveExts.includes(ext)) return FileCategory.ARCHIVES;

    return FileCategory.OTHERS;
  }

  /**
   * 生成子目录路径（按日期）
   */
  private generateSubPath(date: Date): string {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');

    // 格式: 2026/02-23/
    return `${year}/${month}-${day}/`;
  }

  /**
   * 判断是否支持预览
   */
  private isPreviewable(category: FileCategory, mimeType?: string): boolean {
    const previewableCategories = [
      FileCategory.IMAGES,
      FileCategory.VIDEOS,
      FileCategory.DOCUMENTS,
      FileCategory.AUDIO
    ];
    return previewableCategories.includes(category);
  }

  /**
   * 获取缩略图策略
   */
  private getThumbnailStrategy(category: FileCategory, file: FileInfo): ThumbnailStrategy {
    switch (category) {
      case FileCategory.IMAGES:
        return { generate: true, size: [400, 400], format: 'webp' };
      case FileCategory.VIDEOS:
        return { generate: true, type: 'poster', time: '00:00:01' };
      case FileCategory.DOCUMENTS:
        if (file.mimeType?.includes('pdf')) {
          return { generate: true, type: 'pdf_preview', pages: 1 };
        }
        return { generate: false };
      default:
        return { generate: false };
    }
  }
}
```

### 6.3 自动整理引擎

```typescript
// 文件自动整理引擎
class FileOrganizationEngine {
  private classifier: SmartFileClassifier;
  private blobStorage: BlobStorage;
  private config: OrganizationConfig;

  constructor(config: OrganizationConfig) {
    this.config = config;
    this.classifier = new SmartFileClassifier();
    this.blobStorage = new BlobStorage();
  }

  /**
   * 处理新文件（从对话消息中接收）
   */
  async processIncomingFile(
    file: IncomingFile,
    context: ProcessingContext
  ): Promise<OrganizedFile> {
    // 1. 分类文件
    const classification = await this.classifier.classify(file);

    // 2. 计算文件哈希（用于去重）
    const hash = await this.computeFileHash(file.path);

    // 3. 检查是否已存在
    const existingBlob = await this.blobStorage.getBlobByHash(hash);

    let blobId: string;
    let isDuplicate = false;

    if (existingBlob) {
      // 3a. 已存在：增加引用计数
      await this.blobStorage.incrementRef(existingBlob.hash);
      blobId = existingBlob.hash;
      isDuplicate = true;
    } else {
      // 3b. 新文件：存入Blob池
      blobId = await this.blobStorage.store(file.path, {
        hash,
        mimeType: file.mimeType,
        size: file.size,
        originalName: file.name,
        source: context.conversationId,
        uploadedAt: new Date()
      });
    }

    // 4. 创建分类软连接
    const organizedPath = await this.createOrganizedLink(
      blobId,
      classification,
      file.name
    );

    // 5. 生成缩略图（如果需要）
    const thumbnailPath = await this.generateThumbnail(
      blobId,
      classification.thumbnailStrategy
    );

    // 6. 记录文件引用
    await this.recordFileReference({
      blobId,
      conversationId: context.conversationId,
      messageId: context.messageId,
      organizedPath,
      thumbnailPath,
      classification,
      isDuplicate
    });

    return {
      blobId,
      organizedPath,
      thumbnailPath,
      category: classification.category,
      isDuplicate
    };
  }

  /**
   * 创建分类软连接
   */
  private async createOrganizedLink(
    blobId: string,
    classification: FileClassifier,
    originalName: string
  ): Promise<string> {
    // Blob文件实际路径
    const blobPath = this.blobStorage.getPath(blobId);

    // 目标分类目录
    const baseDir = path.join(
      this.config.basePath,
      classification.category
    );

    // 子目录（按日期）
    const subDir = path.join(baseDir, classification.subPath);

    // 确保目录存在
    await fs.mkdir(subDir, { recursive: true });

    // 生成有意义的文件名
    const organizedName = this.generateOrganizedName(originalName, blobId);
    const linkPath = path.join(subDir, organizedName);

    // 创建软连接（优先）或硬连接
    if (this.config.useSymlinks) {
      await fs.symlink(blobPath, linkPath);
    } else {
      await fs.link(blobPath, linkPath);
    }

    return linkPath;
  }

  /**
   * 生成整理后的文件名
   */
  private generateOrganizedName(originalName: string, blobId: string): string {
    const ext = path.extname(originalName);
    const baseName = path.basename(originalName, ext);

    // 保留原文件名 + 短哈希前缀（防止冲突）
    const shortHash = blobId.substring(0, 8);
    const timestamp = Date.now();

    // 格式: originalname_8charhash_timestamp.ext
    return `${baseName}_${shortHash}_${timestamp}${ext}`;
  }

  /**
   * 生成缩略图
   */
  private async generateThumbnail(
    blobId: string,
    strategy: ThumbnailStrategy
  ): Promise<string | null> {
    if (!strategy.generate) return null;

    const blobPath = this.blobStorage.getPath(blobId);
    const thumbnailDir = path.join(this.config.basePath, 'cache', 'thumbnails');
    await fs.mkdir(thumbnailDir, { recursive: true });

    const thumbnailPath = path.join(thumbnailDir, `${blobId}.webp`);

    try {
      switch (strategy.type) {
        case 'image':
          await this.generateImageThumbnail(blobPath, thumbnailPath, strategy.size);
          break;
        case 'poster':
          await this.generateVideoPoster(blobPath, thumbnailPath, strategy.time);
          break;
        case 'pdf_preview':
          await this.generatePDFPreview(blobPath, thumbnailPath, strategy.pages);
          break;
        default:
          return null;
      }

      return thumbnailPath;
    } catch (err) {
      console.error('Thumbnail generation failed:', err);
      return null;
    }
  }

  /**
   * 清理孤立的软连接
   */
  async cleanupBrokenLinks(): Promise<CleanupResult> {
    const result: CleanupResult = {
      checked: 0,
      removed: 0,
      errors: []
    };

    for (const category of Object.values(FileCategory)) {
      const categoryDir = path.join(this.config.basePath, category);

      if (!await this.dirExists(categoryDir)) continue;

      const entries = await this.listAllFiles(categoryDir);

      for (const entry of entries) {
        result.checked++;

        try {
          // 检查软连接是否指向有效的Blob
          const stat = await fs.lstat(entry);

          if (stat.isSymbolicLink()) {
            const target = await fs.readlink(entry);
            const targetExists = await fs.access(target).then(() => true).catch(() => false);

            if (!targetExists) {
              await fs.unlink(entry);
              result.removed++;
            }
          }
        } catch (err) {
          result.errors.push({ path: entry, error: err.message });
        }
      }
    }

    return result;
  }
}

// 配置接口
interface OrganizationConfig {
  basePath: string;           // 基础路径 ~/.silly/data/files/
  useSymlinks: boolean;       // 使用软连接（true）或硬连接（false）
  organizeByDate: boolean;    // 按日期子目录组织
  generateThumbnails: boolean; // 自动生成缩略图
  preserveOriginalNames: boolean; // 保留原始文件名
}

// 处理结果
interface OrganizedFile {
  blobId: string;
  organizedPath: string;
  thumbnailPath: string | null;
  category: FileCategory;
  isDuplicate: boolean;
}
```

### 6.4 数据库表设计

```sql
-- 文件整理记录表
CREATE TABLE organized_files (
    id TEXT PRIMARY KEY,
    blob_hash TEXT NOT NULL REFERENCES blobs(hash),

    -- 来源信息
    conversation_id TEXT REFERENCES conversations(id) ON DELETE SET NULL,
    message_id TEXT REFERENCES messages(id) ON DELETE SET NULL,

    -- 分类信息
    category TEXT NOT NULL CHECK (category IN ('images', 'videos', 'documents', 'audio', 'archives', 'others')),
    sub_path TEXT NOT NULL,  -- 子目录路径 (2026/02-23/)

    -- 组织后的文件信息
    organized_path TEXT NOT NULL,      -- 软连接路径
    organized_name TEXT NOT NULL,      -- 整理后的文件名
    thumbnail_path TEXT,               -- 缩略图路径

    -- 原始信息
    original_name TEXT NOT NULL,
    original_path TEXT,                -- 原始上传路径（如果有）

    -- 状态
    is_duplicate BOOLEAN DEFAULT FALSE,
    is_deleted BOOLEAN DEFAULT FALSE,

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    accessed_at TIMESTAMP,             -- 最后访问时间

    INDEX idx_blob_hash (blob_hash),
    INDEX idx_conversation (conversation_id),
    INDEX idx_category (category),
    INDEX idx_created_at (created_at)
);

-- 文件访问统计表（用于智能清理）
CREATE TABLE file_access_stats (
    blob_hash TEXT PRIMARY KEY REFERENCES blobs(hash),

    access_count INTEGER DEFAULT 0,
    last_accessed TIMESTAMP,

    -- 访问频率评分 (0-100)
    hot_score INTEGER DEFAULT 50,

    -- 更新频率
    daily_access INTEGER DEFAULT 0,
    weekly_access INTEGER DEFAULT 0,
    monthly_access INTEGER DEFAULT 0,

    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 文件标签表（用于搜索）
CREATE TABLE file_tags (
    id TEXT PRIMARY KEY,
    file_id TEXT NOT NULL REFERENCES organized_files(id),
    tag TEXT NOT NULL,
    source TEXT DEFAULT 'auto',  -- auto: 自动标签, user: 用户标签, ai: AI标签

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(file_id, tag),
    INDEX idx_tag (tag)
);
```

### 6.5 使用示例

```typescript
// 初始化整理引擎
const engine = new FileOrganizationEngine({
  basePath: path.join(os.homedir(), '.silly', 'data', 'files'),
  useSymlinks: true,
  organizeByDate: true,
  generateThumbnails: true,
  preserveOriginalNames: true
});

// 处理从对话接收的文件
async function handleIncomingFile(file: UploadedFile, messageContext: MessageContext) {
  const result = await engine.processIncomingFile(
    {
      path: file.tempPath,
      name: file.originalName,
      mimeType: file.mimeType,
      size: file.size,
      createdAt: new Date()
    },
    {
      conversationId: messageContext.conversationId,
      messageId: messageContext.messageId,
      senderId: messageContext.senderId
    }
  );

  console.log(`文件已整理:`);
  console.log(`  分类: ${result.category}`);
  console.log(`  路径: ${result.organizedPath}`);
  console.log(`  是否重复: ${result.isDuplicate}`);

  return result;
}

// 定期清理任务
async function scheduledCleanup() {
  // 清理损坏的软连接
  const cleanupResult = await engine.cleanupBrokenLinks();
  console.log(`清理完成: 检查 ${cleanupResult.checked} 个, 删除 ${cleanupResult.removed} 个损坏链接`);

  // 更新访问统计
  await updateAccessStats();

  // 清理过期缩略图
  await cleanupExpiredThumbnails();
}
```

### 5.3 缓存管理

```typescript
class CacheManager {
  private cacheDir: string;
  private maxSize: number;
  private maxAge: number;

  constructor(config: CacheConfig) {
    this.cacheDir = config.cacheDir;
    this.maxSize = config.maxSize;
    this.maxAge = config.maxAge;
  }

  /**
   * 获取缓存项
   */
  async get(key: string): Promise<Buffer | null> {
    const cachePath = this.getCachePath(key);

    try {
      const stat = await fs.stat(cachePath);

      // 检查是否过期
      if (Date.now() - stat.mtime.getTime() > this.maxAge) {
        await fs.unlink(cachePath);
        return null;
      }

      // 更新访问时间
      await fs.utimes(cachePath, new Date(), stat.mtime);

      return fs.readFile(cachePath);
    } catch (err) {
      return null;
    }
  }

  /**
   * 设置缓存项
   */
  async set(key: string, data: Buffer): Promise<void> {
    // 检查容量，必要时清理
    await this.ensureSpace(data.length);

    const cachePath = this.getCachePath(key);
    await fs.mkdir(path.dirname(cachePath), { recursive: true });
    await fs.writeFile(cachePath, data);
  }

  /**
   * 获取缓存文件路径
   */
  private getCachePath(key: string): string {
    // 使用哈希分片
    const hash = createHash('sha256').update(key).digest('hex');
    const level1 = hash.substring(0, 2);
    const level2 = hash.substring(2, 4);

    return path.join(this.cacheDir, level1, level2, hash);
  }

  /**
   * 确保有足够空间
   */
  private async ensureSpace(requiredBytes: number): Promise<void> {
    const currentSize = await this.calculateSize();

    if (currentSize + requiredBytes > this.maxSize) {
      const bytesToFree = currentSize + requiredBytes - this.maxSize;
      await this.evictLRU(bytesToFree);
    }
  }

  /**
   * LRU淘汰
   */
  private async evictLRU(bytesToFree: number): Promise<void> {
    const entries = await this.listCacheEntries();

    // 按访问时间排序（最旧的在前）
    entries.sort((a, b) => a.atime - b.atime);

    let freed = 0;

    for (const entry of entries) {
      if (freed >= bytesToFree) break;

      try {
        await fs.unlink(entry.path);
        freed += entry.size;
      } catch (err) {
        // 忽略错误
      }
    }
  }

  /**
   * 预热缓存
   */
  async warmCache(keys: string[]): Promise<void> {
    // 异步预加载
    for (const key of keys) {
      this.get(key).catch(() => {});
    }
  }

  /**
   * 清空缓存
   */
  async clear(): Promise<void> {
    const entries = await fs.readdir(this.cacheDir);

    for (const entry of entries) {
      await fs.rm(path.join(this.cacheDir, entry), { recursive: true, force: true });
    }
  }

  /**
   * 获取缓存统计
   */
  async getStats(): Promise<CacheStats> {
    const entries = await this.listCacheEntries();
    const totalSize = entries.reduce((sum, e) => sum + e.size, 0);

    return {
      itemCount: entries.length,
      totalSize,
      maxSize: this.maxSize,
      utilization: totalSize / this.maxSize
    };
  }
}

interface CacheConfig {
  cacheDir: string;
  maxSize: number;      // 最大字节数
  maxAge: number;       // 最大存活时间（毫秒）
}

interface CacheStats {
  itemCount: number;
  totalSize: number;
  maxSize: number;
  utilization: number;
}
```

## 附录

### A. 存储配额计算

```typescript
// 默认存储配额
const DEFAULT_QUOTAS = {
  // 数据库大小限制 (MB)
  databaseSize: 100,

  // 文件存储池大小限制 (GB)
  blobPoolSize: 10,

  // 缓存大小限制 (MB)
  cacheSize: 500,

  // 单文件大小限制 (MB)
  maxFileSize: 100,

  // 单次上传文件数限制
  maxFilesPerUpload: 10
};

// 计算存储使用情况
async function calculateStorageUsage(): Promise<StorageUsage> {
  const db = await getDatabaseSize();
  const blobs = await getBlobsSize();
  const cache = await getCacheSize();

  return {
    database: { used: db, limit: DEFAULT_QUOTAS.databaseSize },
    blobs: { used: blobs, limit: DEFAULT_QUOTAS.blobPoolSize * 1024 },
    cache: { used: cache, limit: DEFAULT_QUOTAS.cacheSize },
    total: { used: db + blobs + cache, limit: (DEFAULT_QUOTAS.databaseSize + DEFAULT_QUOTAS.blobPoolSize * 1024 + DEFAULT_QUOTAS.cacheSize) }
  };
}
```

### B. 错误处理

```typescript
// 存储相关错误码
enum StorageErrorCode {
  // 本地错误
  INSUFFICIENT_SPACE = 'STORAGE_001',
  FILE_TOO_LARGE = 'STORAGE_002',
  INVALID_FILE_TYPE = 'STORAGE_003',
  CORRUPTED_DATA = 'STORAGE_004',

  // 云端错误
  CLOUD_AUTH_FAILED = 'CLOUD_001',
  CLOUD_RATE_LIMITED = 'CLOUD_002',
  CLOUD_SYNC_CONFLICT = 'CLOUD_003',
  CLOUD_PROVIDER_ERROR = 'CLOUD_004',

  // 加密错误
  ENCRYPTION_FAILED = 'CRYPTO_001',
  DECRYPTION_FAILED = 'CRYPTO_002',
  INVALID_KEY = 'CRYPTO_003'
}

class StorageError extends Error {
  constructor(
    public code: StorageErrorCode,
    message: string,
    public details?: any
  ) {
    super(message);
    this.name = 'StorageError';
  }
}
```

### C. 性能优化建议

1. **数据库优化**
   - 启用 WAL 模式提升并发性能
   - 定期执行 VACUUM 回收空间
   - 关键查询添加索引

2. **文件存储优化**
   - 使用流式读写处理大文件
   - 异步批量处理小文件
   - 合理设置分片层级

3. **同步优化**
   - 增量同步减少数据传输
   - 压缩传输内容
   - 使用断点续传

4. **缓存优化**
   - 多级缓存策略
   - 智能预加载
   - 定期清理过期数据
