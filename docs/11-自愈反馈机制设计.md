# 自愈反馈机制设计文档

## 概述

本文档描述 SillyChat 的自愈反馈系统设计，实现自动收集bug、推送到大模型自动诊断修复、问题档案上传服务器形成自愈循环的完整机制。

---

## 1. 系统整体架构

### 1.1 自愈循环流程

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              自愈反馈循环 (Self-Healing Loop)                  │
└─────────────────────────────────────────────────────────────────────────────┘

   ┌───────────┐     ┌───────────┐     ┌───────────┐     ┌───────────┐
   │  错误发生  │────►│  自动收集  │────►│  智能分类  │────►│  模型诊断  │
   └───────────┘     └───────────┘     └───────────┘     └─────┬─────┘
         ▲                                                     │
         │                                                     ▼
   ┌─────┴─────┐     ┌───────────┐     ┌───────────┐     ┌───────────┐
   │  效果评估  │◄────│  灰度发布  │◄────│  修复验证  │◄────│  方案生成  │
   └───────────┘     └───────────┘     └───────────┘     └───────────┘
```

### 1.2 组件架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              自愈反馈系统架构                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │                          客户端层 (Client Side)                          ││
│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌─────────────────────┐  ││
│  │  │ 错误捕获器 │  │ 日志收集器 │  │ 上下文采集 │  │ 本地预处理引擎       │  ││
│  │  │  (Hook)   │  │           │  │           │  │  (去敏/压缩/分类)    │  ││
│  │  └─────┬─────┘  └─────┬─────┘  └─────┬─────┘  └─────────────────────┘  ││
│  │        └──────────────┴──────────────┘                                 ││
│  │                          │                                             ││
│  │        ┌─────────────────┴─────────────────┐                           ││
│  │        ▼                                   ▼                           ││
│  │  ┌───────────┐                     ┌───────────┐                      ││
│  │  │ 本地存储   │                     │ 用户授权  │                      ││
│  │  │ (SQLite)  │                     │  对话框   │                      ││
│  │  └───────────┘                     └───────────┘                      ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│                                      │                                      │
│                                      ▼                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │                          网关层 (Gateway Layer)                          ││
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────────────┐ ││
│  │  │  问题报告API    │  │  匿名化处理     │  │  上报队列管理           │ ││
│  │  │  /report/issue  │  │  (PII过滤)      │  │  (优先级/限流)          │ ││
│  │  └─────────────────┘  └─────────────────┘  └─────────────────────────┘ ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│                                      │                                      │
│                                      ▼                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │                          自愈服务层 (Self-Healing Service)               ││
│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌─────────────────────┐  ││
│  │  │ 问题分类器 │  │ 重复检测器 │  │ 大模型诊断 │  │ 修复方案生成器       │  ││
│  │  │           │  │           │  │  引擎     │  │                     │  ││
│  │  └───────────┘  └───────────┘  └─────┬─────┘  └─────────────────────┘  ││
│  │                                      │                                 ││
│  │        ┌─────────────────────────────┼─────────────────┐               ││
│  │        ▼                             ▼                 ▼               ││
│  │  ┌───────────┐                 ┌───────────┐     ┌───────────┐        ││
│  │  │ 测试验证  │                 │ 补丁打包  │     │ 风险评估  │        ││
│  │  │  沙箱    │                 │           │     │           │        ││
│  │  └─────┬─────┘                 └─────┬─────┘     └───────────┘        ││
│  │        │                             │                                ││
│  │        └─────────────────────┬───────┘                                ││
│  │                              ▼                                        ││
│  │  ┌─────────────────────────────────────────────────────────────┐     ││
│  │  │                    灰度发布管理器                            │     ││
│  │  │  (金丝雀发布 → 10%用户 → 50%用户 → 全量发布)                 │     ││
│  │  └─────────────────────────────────────────────────────────────┘     ││
│  └─────────────────────────────────────────────────────────────────────────┘│
│                                      │                                      │
│                                      ▼                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐│
│  │                          知识库层 (Knowledge Base)                       ││
│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌─────────────────────┐  ││
│  │  │ 问题档案库 │  │ 解决方案库 │  │ 代码模式库 │  │  效果追踪库          │  ││
│  │  │ (向量DB)  │  │ (关系DB)  │  │ (图DB)   │  │  (时序DB)           │  ││
│  │  └───────────┘  └───────────┘  └───────────┘  └─────────────────────┘  ││
│  └─────────────────────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 2. Bug自动收集机制

### 2.1 错误捕获架构

```typescript
// 核心错误捕获器
interface ErrorCollector {
  // 全局错误处理
  captureGlobalErrors(): void;

  // Promise拒绝捕获
  captureUnhandledRejections(): void;

  // 框架特定错误
  captureFrameworkErrors(): void;

  // 性能异常检测
  capturePerformanceIssues(): void;
}

// 错误报告结构
interface ErrorReport {
  id: string;                    // 唯一标识
  timestamp: number;             // 发生时间
  severity: 'P0' | 'P1' | 'P2' | 'P3' | 'P4';

  // 错误信息
  error: {
    type: string;                // 错误类型
    message: string;             // 错误消息
    stack: string;               // 堆栈跟踪
    code?: string;               // 错误代码
  };

  // 上下文信息
  context: {
    userAction: UserAction[];    // 用户操作序列
    componentStack: string[];    // 组件层级
    networkStatus: NetworkInfo;  // 网络状态
    systemInfo: SystemInfo;      // 系统信息
    memorySnapshot?: MemoryInfo; // 内存快照
  };

  // 日志数据
  logs: {
    console: LogEntry[];         // 控制台日志
    app: LogEntry[];             // 应用日志
    network: NetworkLog[];       // 网络请求日志
  };

  // 截图/录屏 (可选)
  media?: {
    screenshot?: Blob;           // 屏幕截图
    screenRecording?: Blob;      // 录屏数据
  };
}
```

### 2.2 客户端实现代码

```typescript
// src/self-healing/error-collector.ts

export class SelfHealingErrorCollector {
  private reportQueue: ErrorReport[] = [];
  private userActionLog: UserAction[] = [];
  private config: CollectorConfig;

  constructor(config: CollectorConfig) {
    this.config = {
      maxActions: 50,
      maxLogs: 100,
      enableScreenshot: false,
      enableRecording: false,
      ...config
    };
    this.init();
  }

  private init(): void {
    this.setupGlobalErrorHandler();
    this.setupPromiseRejectionHandler();
    this.setupFrameworkErrorHandler();
    this.setupUserActionTracking();
    this.setupPerformanceMonitoring();
  }

  // 全局错误处理
  private setupGlobalErrorHandler(): void {
    window.addEventListener('error', (event) => {
      this.collectError({
        type: 'javascript',
        message: event.message,
        stack: event.error?.stack,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno
      });
    });
  }

  // Promise拒绝捕获
  private setupPromiseRejectionHandler(): void {
    window.addEventListener('unhandledrejection', (event) => {
      this.collectError({
        type: 'promise',
        message: event.reason?.message || String(event.reason),
        stack: event.reason?.stack,
        reason: event.reason
      });
    });
  }

  // 框架特定错误 (React/Vue/Electron)
  private setupFrameworkErrorHandler(): void {
    // React Error Boundary
    if (window.React) {
      window.React.errorHandler = (error, info) => {
        this.collectError({
          type: 'react',
          message: error.message,
          stack: error.stack,
          componentStack: info.componentStack
        });
      };
    }

    // Electron 崩溃报告
    if (window.electron) {
      window.electron.on('crashed', (event, killed) => {
        this.collectError({
          type: 'crash',
          message: `Process crashed: ${killed ? 'killed' : 'crashed'}`,
          crashInfo: event
        });
      });
    }
  }

  // 用户操作追踪
  private setupUserActionTracking(): void {
    const trackableEvents = ['click', 'input', 'submit', 'keydown'];

    trackableEvents.forEach(eventType => {
      document.addEventListener(eventType, (event) => {
        const target = event.target as HTMLElement;
        this.userActionLog.push({
          type: eventType,
          timestamp: Date.now(),
          target: {
            tagName: target.tagName,
            id: target.id,
            className: target.className,
            textContent: target.textContent?.slice(0, 100)
          },
          payload: this.extractEventPayload(event)
        });

        // 限制日志数量
        if (this.userActionLog.length > this.config.maxActions) {
          this.userActionLog.shift();
        }
      }, true);
    });
  }

  // 性能监控
  private setupPerformanceMonitoring(): void {
    // 长任务检测
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.duration > 50) { // 超过50ms认为卡顿
          this.collectPerformanceIssue({
            type: 'longtask',
            duration: entry.duration,
            entry
          });
        }
      }
    });
    observer.observe({ entryTypes: ['longtask'] });

    // 内存泄漏检测
    setInterval(() => {
      const memory = (performance as any).memory;
      if (memory && memory.usedJSHeapSize > memory.jsHeapSizeLimit * 0.9) {
        this.collectPerformanceIssue({
          type: 'memory',
          used: memory.usedJSHeapSize,
          limit: memory.jsHeapSizeLimit
        });
      }
    }, 60000);
  }

  // 收集错误
  private async collectError(errorInfo: ErrorInfo): Promise<void> {
    const report: ErrorReport = {
      id: this.generateReportId(),
      timestamp: Date.now(),
      severity: this.assessSeverity(errorInfo),
      error: {
        type: errorInfo.type,
        message: errorInfo.message,
        stack: errorInfo.stack,
        code: errorInfo.code
      },
      context: {
        userAction: [...this.userActionLog],
        componentStack: errorInfo.componentStack || [],
        networkStatus: this.getNetworkStatus(),
        systemInfo: this.getSystemInfo(),
        memorySnapshot: await this.captureMemorySnapshot()
      },
      logs: {
        console: this.getConsoleLogs(),
        app: this.getAppLogs(),
        network: this.getNetworkLogs()
      }
    };

    // 本地预处理
    const processed = await this.preprocessReport(report);

    // 存入队列
    this.reportQueue.push(processed);

    // 尝试上报
    this.flushReportQueue();
  }

  // 严重程度评估
  private assessSeverity(error: ErrorInfo): ErrorSeverity {
    if (error.type === 'crash') return 'P0';
    if (error.type === 'react' && error.message?.includes('render')) return 'P1';
    if (error.message?.includes('out of memory')) return 'P0';
    if (error.stack?.includes('payment')) return 'P1';
    return 'P2';
  }

  // 本地预处理（去敏、压缩）
  private async preprocessReport(report: ErrorReport): Promise<ErrorReport> {
    // 敏感信息过滤
    report = this.sanitizeReport(report);

    // 压缩堆栈
    report.error.stack = await this.compressStack(report.error.stack);

    // 截断长文本
    report.error.message = report.error.message.slice(0, 1000);

    return report;
  }

  // 敏感信息过滤
  private sanitizeReport(report: ErrorReport): ErrorReport {
    const sensitivePatterns = [
      { pattern: /password[=:]\s*\S+/gi, replacement: 'password=***' },
      { pattern: /token[=:]\s*[\w-]+/gi, replacement: 'token=***' },
      { pattern: /api[_-]?key[=:]\s*\S+/gi, replacement: 'api_key=***' },
      { pattern: /[\w.-]+@[\w.-]+\.\w+/g, replacement: '[EMAIL]' },
      { pattern: /\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/g, replacement: '[CARD]' }
    ];

    let sanitized = JSON.stringify(report);
    sensitivePatterns.forEach(({ pattern, replacement }) => {
      sanitized = sanitized.replace(pattern, replacement);
    });

    return JSON.parse(sanitized);
  }
}
```

---

## 3. 问题分类与分级

### 3.1 分类体系

```typescript
// 问题分类
enum IssueCategory {
  // 运行时错误
  RUNTIME_ERROR = 'runtime_error',
  CRASH = 'crash',
  MEMORY_LEAK = 'memory_leak',

  // 性能问题
  PERFORMANCE = 'performance',
  SLOW_RENDER = 'slow_render',
  NETWORK_TIMEOUT = 'network_timeout',

  // UI问题
  UI_GLITCH = 'ui_glitch',
  LAYOUT_BREAK = 'layout_break',
  ANIMATION_FAIL = 'animation_fail',

  // 功能问题
  FEATURE_BROKEN = 'feature_broken',
  DATA_CORRUPTION = 'data_corruption',
  SYNC_FAILURE = 'sync_failure',

  // 安全问题
  SECURITY = 'security',
  AUTH_FAILURE = 'auth_failure',
  PERMISSION_ERROR = 'permission_error'
}

// 严重程度
enum SeverityLevel {
  P0 = 'P0', // 严重：应用崩溃/数据丢失/安全漏洞
  P1 = 'P1', // 高：核心功能不可用
  P2 = 'P2', // 中：非核心功能异常
  P3 = 'P3', // 低：轻微UI问题
  P4 = 'P4'  // 极低：优化建议
}

// 影响范围
interface ImpactScope {
  users: 'single' | 'multiple' | 'all';
  platforms: ('windows' | 'macos' | 'android' | 'ios' | 'web')[];
  versions: string[];
  features: string[];
}
```

### 3.2 智能分类器

```typescript
// src/self-healing/issue-classifier.ts

export class IssueClassifier {
  private model: MLModel;

  async classify(report: ErrorReport): Promise<ClassificationResult> {
    // 特征提取
    const features = this.extractFeatures(report);

    // 多维度分类
    const [
      category,
      severity,
      component
    ] = await Promise.all([
      this.classifyCategory(features),
      this.assessSeverity(features, report),
      this.identifyComponent(features)
    ]);

    // 影响范围分析
    const scope = await this.analyzeImpact(report);

    // 重复检测
    const duplicateOf = await this.detectDuplicate(report);

    return {
      category,
      severity,
      component,
      scope,
      duplicateOf,
      confidence: this.calculateConfidence(features)
    };
  }

  private extractFeatures(report: ErrorReport): IssueFeatures {
    return {
      // 错误特征
      errorType: report.error.type,
      errorKeywords: this.extractKeywords(report.error.message),
      stackFrames: this.parseStackFrames(report.error.stack),

      // 上下文特征
      userActions: report.context.userAction.map(a => a.type),
      componentDepth: report.context.componentStack.length,
      networkStatus: report.context.networkStatus.online,

      // 系统特征
      platform: report.context.systemInfo.platform,
      appVersion: report.context.systemInfo.appVersion,
      osVersion: report.context.systemInfo.osVersion
    };
  }

  private async classifyCategory(features: IssueFeatures): Promise<IssueCategory> {
    // 规则引擎 + 机器学习

    // 规则优先
    if (features.errorType === 'crash') return IssueCategory.CRASH;
    if (features.errorKeywords.includes('memory')) return IssueCategory.MEMORY_LEAK;
    if (features.errorKeywords.includes('timeout')) return IssueCategory.NETWORK_TIMEOUT;

    // ML分类
    return this.model.predictCategory(features);
  }

  private async detectDuplicate(report: ErrorReport): Promise<string | null> {
    // 生成错误指纹
    const fingerprint = this.generateFingerprint(report);

    // 相似度搜索
    const similar = await this.searchSimilarIssues(fingerprint);

    if (similar.length > 0 && similar[0].similarity > 0.9) {
      return similar[0].issueId;
    }

    return null;
  }

  private generateFingerprint(report: ErrorReport): string {
    // 基于堆栈和错误类型的指纹
    const stackHash = report.error.stack
      ?.split('\n')
      .slice(0, 5)
      .map(line => line.replace(/:\d+:\d+$/, '')) // 去除行号
      .join('|');

    return crypto.createHash('sha256')
      .update(`${report.error.type}|${report.error.message}|${stackHash}`)
      .digest('hex');
  }
}
```

---

## 4. 大模型自动诊断

### 4.1 诊断引擎架构

```typescript
// src/self-healing/diagnosis-engine.ts

interface DiagnosisEngine {
  // 代码分析
  analyzeCode(report: ErrorReport): Promise<CodeAnalysis>;

  // 根因分析
  rootCauseAnalysis(report: ErrorReport): Promise<RootCause>;

  // 修复方案生成
  generateFix(report: ErrorReport, analysis: CodeAnalysis): Promise<FixProposal>;

  // 风险评估
  assessRisk(fix: FixProposal): Promise<RiskAssessment>;
}

// 诊断结果
interface DiagnosisResult {
  rootCause: string;
  affectedFiles: string[];
  confidence: number;
  suggestedFixes: FixProposal[];
  estimatedTime: number;
  needHumanReview: boolean;
}
```

### 4.2 提示词设计

```typescript
// 诊断提示词模板
const DIAGNOSIS_PROMPT = `
你是一位资深软件工程师，专门负责分析和修复应用程序错误。
请根据以下错误报告进行分析：

## 错误信息
类型：{{error.type}}
消息：{{error.message}}
堆栈：{{error.stack}}

## 上下文
用户操作序列：{{context.userAction}}
组件层级：{{context.componentStack}}
系统信息：{{context.systemInfo}}

## 相关代码
{{sourceCode}}

请按以下格式输出分析结果：

### 1. 根因分析
- 直接原因：
- 根本原因：
- 触发条件：

### 2. 影响评估
- 影响范围：
- 数据风险：
- 安全风险：

### 3. 修复方案
方案A（快速修复）：
- 修改文件：
- 修改内容：
- 预计时间：

方案B（根治修复）：
- 修改文件：
- 修改内容：
- 预计时间：

### 4. 测试建议
- 单元测试：
- 集成测试：
- 回归测试：

### 5. 置信度评分
- 分析置信度：0-100
- 建议人工复核：是/否
`;
```

### 4.3 修复方案生成

```typescript
// src/self-healing/fix-generator.ts

export class FixGenerator {
  private llm: LLMService;
  private codeRepo: CodeRepository;

  async generateFix(
    report: ErrorReport,
    diagnosis: DiagnosisResult
  ): Promise<FixProposal> {
    // 获取相关代码
    const context = await this.gatherCodeContext(report);

    // 生成修复
    const prompt = this.buildFixPrompt(report, diagnosis, context);
    const response = await this.llm.generate(prompt, {
      temperature: 0.2,
      maxTokens: 2000
    });

    // 解析修复方案
    const fix = this.parseFixResponse(response);

    // 验证修复可行性
    const validation = await this.validateFix(fix, context);

    return {
      ...fix,
      validation,
      originalReport: report.id
    };
  }

  private async gatherCodeContext(report: ErrorReport): Promise<CodeContext> {
    // 从堆栈解析文件位置
    const locations = this.parseStackLocations(report.error.stack);

    // 获取源码
    const files = await Promise.all(
      locations.map(async loc => ({
        path: loc.file,
        content: await this.codeRepo.getFile(loc.file),
        line: loc.line,
        function: loc.function
      }))
    );

    // 获取相关依赖
    const dependencies = await this.analyzeDependencies(files);

    return { files, dependencies };
  }

  private async validateFix(
    fix: FixProposal,
    context: CodeContext
  ): Promise<FixValidation> {
    const results: ValidationResult[] = [];

    // 语法检查
    results.push(await this.checkSyntax(fix));

    // 类型检查
    results.push(await this.checkTypes(fix, context));

    // 静态分析
    results.push(await this.runStaticAnalysis(fix));

    // 安全扫描
    results.push(await this.securityScan(fix));

    return {
      passed: results.every(r => r.passed),
      results,
      score: results.reduce((sum, r) => sum + r.score, 0) / results.length
    };
  }
}
```

---

## 5. 修复方案验证与测试

### 5.1 沙箱验证

```typescript
// src/self-healing/sandbox-validator.ts

export class SandboxValidator {
  private sandbox: SandboxEnvironment;

  async validateInSandbox(
    fix: FixProposal,
    originalReport: ErrorReport
  ): Promise<SandboxResult> {
    // 创建隔离环境
    const env = await this.sandbox.create({
      image: 'sillychat-test:latest',
      resources: {
        memory: '2g',
        cpu: '2'
      }
    });

    try {
      // 1. 部署原始代码
      await env.deployOriginalCode();

      // 2. 复现问题
      const reproduction = await env.reproduceIssue(originalReport);
      if (!reproduction.success) {
        return { status: 'cannot_reproduce', logs: reproduction.logs };
      }

      // 3. 应用修复
      await env.applyFix(fix);

      // 4. 验证修复
      const verification = await env.verifyFix(originalReport);

      // 5. 回归测试
      const regression = await env.runRegressionTests();

      return {
        status: verification.success && regression.passed ? 'passed' : 'failed',
        reproduction,
        verification,
        regression,
        logs: await env.getLogs()
      };
    } finally {
      await env.destroy();
    }
  }
}
```

### 5.2 A/B测试框架

```typescript
// src/self-healing/ab-testing.ts

interface ABTestConfig {
  fix: FixProposal;
  controlGroup: number;  // 对照组比例
  testGroup: number;     // 测试组比例
  duration: number;      // 测试时长（小时）
  metrics: string[];     // 监控指标
}

export class ABTestFramework {
  async startTest(config: ABTestConfig): Promise<ABTest> {
    const test: ABTest = {
      id: generateId(),
      ...config,
      status: 'running',
      startTime: Date.now()
    };

    // 部署修复到测试组
    await this.deployToTestGroup(test);

    // 启动监控
    this.startMonitoring(test);

    return test;
  }

  private async evaluateTest(test: ABTest): Promise<TestResult> {
    const metrics = await this.gatherMetrics(test);

    // 关键指标对比
    const comparison = {
      errorRate: this.compareErrorRate(metrics),
      performance: this.comparePerformance(metrics),
      userExperience: this.compareUX(metrics)
    };

    // 统计显著性检验
    const significant = this.checkSignificance(metrics);

    // 决策建议
    if (comparison.errorRate.improved && significant) {
      return { decision: 'rollout', confidence: comparison.errorRate.confidence };
    }
    if (comparison.errorRate.degraded) {
      return { decision: 'rollback', confidence: comparison.errorRate.confidence };
    }
    return { decision: 'continue', confidence: 0.5 };
  }
}
```

---

## 6. 热更新与补丁推送

### 6.1 补丁管理

```typescript
// src/self-healing/patch-manager.ts

interface Patch {
  id: string;
  version: string;
  targetVersion: string;
  fixes: Fix[];
  metadata: {
    createdAt: number;
    severity: SeverityLevel;
    affectedComponents: string[];
  };
  package: {
    diff: Buffer;          // 差异包
    checksum: string;      // 校验和
    size: number;
  };
}

export class PatchManager {
  // 创建补丁
  async createPatch(fixes: FixProposal[]): Promise<Patch> {
    // 生成差异
    const diff = await this.generateDiff(fixes);

    // 签名
    const signature = await this.signPatch(diff);

    // 打包
    return {
      id: generatePatchId(),
      version: this.incrementPatchVersion(),
      fixes: fixes.map(f => f.toFix()),
      package: {
        diff,
        checksum: computeChecksum(diff),
        size: diff.length
      }
    };
  }

  // 增量更新
  async applyPatch(patch: Patch): Promise<void> {
    // 验证签名
    const valid = await this.verifySignature(patch);
    if (!valid) throw new Error('Invalid patch signature');

    // 备份当前版本
    await this.backupCurrentVersion();

    // 应用补丁
    await this.atomicApply(patch);

    // 验证完整性
    const integrity = await this.verifyIntegrity();
    if (!integrity) {
      await this.rollback();
      throw new Error('Patch integrity check failed');
    }
  }

  // 灰度发布
  async rolloutPatch(
    patch: Patch,
    strategy: RolloutStrategy
  ): Promise<void> {
    const stages = [
      { percentage: 0.01, duration: 3600 },   // 1% - 1小时
      { percentage: 0.10, duration: 7200 },   // 10% - 2小时
      { percentage: 0.50, duration: 14400 },  // 50% - 4小时
      { percentage: 1.00, duration: 0 }       // 100%
    ];

    for (const stage of stages) {
      await this.deployToPercentage(patch, stage.percentage);

      if (stage.duration > 0) {
        await this.monitorAndWait(stage.duration);

        const health = await this.checkHealth();
        if (!health.healthy) {
          await this.rollback(patch);
          throw new Error(`Rollout failed at ${stage.percentage * 100}%`);
        }
      }
    }
  }
}
```

### 6.2 紧急修复通道

```typescript
// src/self-healing/emergency-channel.ts

export class EmergencyChannel {
  // P0级别紧急修复
  async emergencyFix(patch: Patch): Promise<void> {
    // 跳过常规流程，直接推送

    // 1. 快速验证（简化检查）
    const quickValidation = await this.quickValidate(patch);
    if (!quickValidation.passed) {
      throw new Error('Emergency patch failed quick validation');
    }

    // 2. 强制推送（用户下次启动时应用）
    await this.forcePush(patch);

    // 3. 通知用户
    this.notifyUsers({
      type: 'critical_update',
      message: '已自动修复严重问题，请重启应用',
      force: true
    });
  }

  // 熔断机制
  async circuitBreakerCheck(): Promise<boolean> {
    const metrics = await this.getRecentMetrics();

    // 如果最近修复导致更多错误，触发熔断
    if (metrics.errorRate.increase > 0.5) { // 错误率增加50%
      await this.autoRollback();
      return false;
    }

    return true;
  }
}
```

---

## 7. 问题档案管理

### 7.1 数据匿名化

```typescript
// src/self-healing/data-anonymizer.ts

export class DataAnonymizer {
  private patterns: AnonymizationPattern[] = [
    { type: 'email', pattern: /\S+@\S+\.\S+/g, replacement: '[EMAIL]' },
    { type: 'phone', pattern: /\b\d{11}\b/g, replacement: '[PHONE]' },
    { type: 'id_card', pattern: /\b\d{17}[\dX]\b/gi, replacement: '[ID]' },
    { type: 'ip', pattern: /\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/g, replacement: '[IP]' },
    { type: 'uuid', pattern: /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/gi, replacement: '[UUID]' }
  ];

  anonymize(report: ErrorReport): AnonymizedReport {
    let serialized = JSON.stringify(report);

    this.patterns.forEach(({ pattern, replacement }) => {
      serialized = serialized.replace(pattern, replacement);
    });

    // 哈希用户ID（保留关联性但不可逆）
    const anonymized = JSON.parse(serialized);
    anonymized.userId = this.hashUserId(report.userId);

    return anonymized;
  }

  private hashUserId(userId: string): string {
    return crypto.createHmac('sha256', ANONYMIZATION_KEY)
      .update(userId)
      .digest('hex');
  }
}
```

### 7.2 加密上传

```typescript
// src/self-healing/secure-uploader.ts

export class SecureUploader {
  // 端到端加密上传
  async uploadEncrypted(report: AnonymizedReport): Promise<void> {
    // 生成临时密钥对
    const keyPair = await this.generateEphemeralKeyPair();

    // 获取服务器公钥
    const serverPublicKey = await this.getServerPublicKey();

    // 协商共享密钥
    const sharedSecret = await this.deriveSharedSecret(
      keyPair.privateKey,
      serverPublicKey
    );

    // 加密数据
    const encrypted = await this.encrypt(report, sharedSecret);

    // 上传
    await this.upload({
      data: encrypted,
      ephemeralPublicKey: keyPair.publicKey,
      timestamp: Date.now()
    });
  }
}
```

---

## 8. 数据库设计

```sql
-- 问题报告表
CREATE TABLE issue_reports (
    id VARCHAR(36) PRIMARY KEY,
    fingerprint VARCHAR(64) NOT NULL UNIQUE,
    severity VARCHAR(2) NOT NULL CHECK (severity IN ('P0','P1','P2','P3','P4')),
    category VARCHAR(50) NOT NULL,

    -- 错误信息（加密存储）
    error_type VARCHAR(50) NOT NULL,
    error_message TEXT,
    error_stack_hash VARCHAR(64),

    -- 上下文（JSON）
    context JSON,

    -- 分类结果
    classification JSON,
    duplicate_of VARCHAR(36) REFERENCES issue_reports(id),

    -- 状态
    status VARCHAR(20) DEFAULT 'new'
        CHECK (status IN ('new','diagnosing','fixing','testing','resolved','closed')),

    -- 元数据
    reported_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    resolved_at TIMESTAMP,
    resolution VARCHAR(20) CHECK (resolution IN ('auto_fixed','manual_fixed','duplicate','wont_fix')),

    INDEX idx_fingerprint (fingerprint),
    INDEX idx_severity_status (severity, status),
    INDEX idx_category (category),
    INDEX idx_reported_at (reported_at)
);

-- 修复记录表
CREATE TABLE fix_records (
    id VARCHAR(36) PRIMARY KEY,
    issue_id VARCHAR(36) NOT NULL REFERENCES issue_reports(id),

    -- 修复方案
    fix_type VARCHAR(20) NOT NULL CHECK (fix_type IN ('ai_generated','manual')),
    diagnosis TEXT NOTn NULL,
    solution TEXT NOT NULL,
    affected_files JSON NOT NULL,

    -- 验证结果
    validation_status VARCHAR(20) CHECK (validation_status IN ('pending','passed','failed')),
    validation_result JSON,

    -- 应用状态
    deployment_status VARCHAR(20) DEFAULT 'pending'
        CHECK (deployment_status IN ('pending','testing','rolling_out','deployed','rolled_back')),
    rollout_percentage DECIMAL(5,2) DEFAULT 0,

    -- 效果追踪
    error_rate_before DECIMAL(5,4),
    error_rate_after DECIMAL(5,4),

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deployed_at TIMESTAMP,

    INDEX idx_issue_id (issue_id),
    INDEX idx_deployment_status (deployment_status)
);

-- 补丁管理表
CREATE TABLE patches (
    id VARCHAR(36) PRIMARY KEY,
    version VARCHAR(20) NOT NULL,
    target_version VARCHAR(20) NOT NULL,

    -- 补丁内容
    package_url VARCHAR(500),
    package_checksum VARCHAR(64) NOT NULL,
    package_size INT NOT NULL,

    -- 签名
    signature VARCHAR(256) NOT NULL,

    -- 影响范围
    severity VARCHAR(2) NOT NULL,
    affected_components JSON,

    -- 状态
    status VARCHAR(20) DEFAULT 'draft'
        CHECK (status IN ('draft','testing','approved','rolled_out','deprecated')),

    -- 统计
    install_count INT DEFAULT 0,
    success_count INT DEFAULT 0,
    rollback_count INT DEFAULT 0,

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    released_at TIMESTAMP,

    INDEX idx_version (version),
    INDEX idx_status (status)
);

-- 自愈效果追踪表（时序数据）
CREATE TABLE healing_metrics (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- 指标类型
    metric_type VARCHAR(50) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,

    -- 数值
    value DECIMAL(15,4) NOT NULL,
    unit VARCHAR(20),

    -- 维度
    platform VARCHAR(20),
    version VARCHAR(20),
    component VARCHAR(50),

    INDEX idx_timestamp (timestamp),
    INDEX idx_metric_type_name (metric_type, metric_name),
    INDEX idx_dimensions (platform, version, component)
);
```

---

## 9. API接口设计

```typescript
// 问题上报API
interface ReportIssueAPI {
  endpoint: 'POST /api/v1/healing/report';
  request: {
    report: ErrorReport;
    consent: boolean;  // 用户同意上传
  };
  response: {
    reportId: string;
    estimatedFixTime?: number;
    severity: SeverityLevel;
  };
}

// 修复查询API
interface QueryFixAPI {
  endpoint: 'GET /api/v1/healing/fix/:issueId';
  response: {
    status: 'diagnosing' | 'fixing' | 'testing' | 'ready' | 'failed';
    progress?: number;
    fix?: FixSummary;
    canApply: boolean;
  };
}

// 补丁下载API
interface DownloadPatchAPI {
  endpoint: 'GET /api/v1/healing/patch/:patchId/download';
  headers: {
    'X-Client-Version': string;
    'X-Platform': string;
  };
  response: {
    url: string;
    checksum: string;
    signature: string;
  };
}

// 效果反馈API
interface FeedbackAPI {
  endpoint: 'POST /api/v1/healing/feedback';
  request: {
    patchId: string;
    success: boolean;
    metrics: {
      errorRate: number;
      performance: number;
    };
    comment?: string;
  };
}
```

---

## 10. 用户授权与隐私

### 10.1 同意机制

```typescript
// src/self-healing/consent-manager.ts

interface ConsentConfig {
  autoReport: boolean;      // 自动上报
  includeLogs: boolean;     // 包含日志
  includeScreenshot: boolean; // 包含截图
  dataRetention: number;    // 数据保留天数
}

export class ConsentManager {
  // 显示同意对话框
  async showConsentDialog(): Promise<ConsentConfig> {
    return new Promise((resolve) => {
      const dialog = new ConsentDialog({
        title: '帮助改进 SillyChat',
        content: `
          我们希望自动收集应用错误信息以快速修复问题。

          收集内容：
          - 错误类型和堆栈信息
          - 应用日志（不含聊天内容）
          - 系统信息（型号、版本）

          保护措施：
          - 数据匿名化处理
          - 端到端加密传输
          - 本地处理优先
          - 随时可关闭
        `,
        options: [
          { id: 'autoReport', label: '自动上报错误', default: true },
          { id: 'includeLogs', label: '包含应用日志', default: true },
          { id: 'includeScreenshot', label: '包含屏幕截图', default: false }
        ]
      });

      dialog.onConfirm(resolve);
    });
  }

  // 检查上报权限
  canReport(severity: SeverityLevel): boolean {
    const config = this.getStoredConsent();

    // P0-P1 级别可以在基本同意下上报
    if (severity <= 'P1') return config.autoReport;

    // P2+ 需要完整同意
    return config.autoReport && config.includeLogs;
  }
}
```

### 10.2 退出机制

```typescript
// 用户可以随时退出
class SelfHealingOptOut {
  async disableSelfHealing(): Promise<void> {
    // 停止收集
    ErrorCollector.stop();

    // 清除本地队列
    await this.clearPendingReports();

    // 更新设置
    await this.updateSettings({ selfHealing: false });

    // 通知服务器删除数据
    await this.requestDataDeletion();
  }
}
```

---

## 11. 实施路线图

| 阶段 | 时间 | 任务 | 优先级 |
|------|------|------|--------|
| **Phase 1** | 2周 | 错误收集器 + 本地存储 | P0 |
| **Phase 2** | 2周 | 问题分类 + 去重 | P0 |
| **Phase 3** | 3周 | 大模型诊断引擎 | P1 |
| **Phase 4** | 2周 | 修复生成 + 验证 | P1 |
| **Phase 5** | 2周 | 热更新 + 灰度发布 | P1 |
| **Phase 6** | 1周 | 知识库 + 分析 | P2 |

---

## 12. 关键指标

| 指标 | 目标 | 说明 |
|------|------|------|
| 问题发现时间 | < 1分钟 | 从错误发生到收集 |
| 诊断时间 | < 5分钟 | P0/P1问题诊断 |
| 修复生成时间 | < 10分钟 | 方案生成 |
| 自动修复成功率 | > 70% | 常见问题的自动修复 |
| 误修复率 | < 5% | 导致更严重的比例 |
| 用户参与率 | > 30% | 同意上报的用户比例 |

---

*文档版本: 1.0*
*创建日期: 2026-02-23*
